<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>mydata_did.patched_protocols.present_proof.v1_0.routes API documentation</title>
<meta name="description" content="Admin routes for presentations." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>mydata_did.patched_protocols.present_proof.v1_0.routes</code></h1>
</header>
<section id="section-intro">
<p>Admin routes for presentations.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Admin routes for presentations.&#34;&#34;&#34;

import json
import math

from aiohttp import web
from aiohttp_apispec import (
    docs,
    match_info_schema,
    querystring_schema,
    request_schema,
    response_schema,
)
from aries_cloudagent.wallet.base import BaseWallet
from aries_cloudagent.wallet.indy import IndyWallet
from marshmallow import fields, validate, validates_schema
from marshmallow.exceptions import ValidationError

from aries_cloudagent.connections.models.connection_record import ConnectionRecord
from aries_cloudagent.holder.base import BaseHolder, HolderError
from aries_cloudagent.indy.util import generate_pr_nonce
from aries_cloudagent.ledger.error import LedgerError
from aries_cloudagent.messaging.decorators.attach_decorator import AttachDecorator
from aries_cloudagent.messaging.models.base import BaseModelError
from aries_cloudagent.messaging.models.openapi import OpenAPISchema
from aries_cloudagent.messaging.valid import (
    INDY_CRED_DEF_ID,
    INDY_DID,
    INDY_EXTRA_WQL,
    INDY_PREDICATE,
    INDY_SCHEMA_ID,
    INDY_VERSION,
    INT_EPOCH,
    NATURAL_NUM,
    UUIDFour,
    UUID4,
    WHOLE_NUM,
)
from aries_cloudagent.storage.error import StorageError, StorageNotFoundError
from aries_cloudagent.utils.tracing import trace_event, get_timer, AdminAPIMessageTracingSchema
from aries_cloudagent.wallet.error import WalletNotFoundError
from aries_cloudagent.protocols.problem_report.v1_0 import internal_error
from dexa_sdk.managers.ada_manager import V2ADAManager
from dexa_sdk.agreements.da.v1_0.records.da_template_record import DataAgreementTemplateRecord
from .manager import PresentationManager
from .message_types import ATTACH_DECO_IDS, PRESENTATION_REQUEST, SPEC_URI
from .messages.inner.presentation_preview import (
    PresentationPreview,
    PresentationPreviewSchema,
)
from .messages.presentation_proposal import PresentationProposal
from .messages.presentation_request import PresentationRequest
from .models.presentation_exchange import (
    V10PresentationExchange,
    V10PresentationExchangeSchema,
)

from ....v1_0.decorators.data_agreement_context_decorator import DataAgreementContextDecorator
from ....v1_0.models.exchange_records.data_agreement_record import DataAgreementV1Record
from ....v1_0.models.data_agreement_negotiation_offer_model import (
    DataAgreementNegotiationOfferBody,
    DataAgreementNegotiationOfferBodySchema
)
from ....v1_0.manager import ADAManager, ADAManagerError
from ....v1_0.models.data_agreement_instance_model import (
    DataAgreementInstance,
    DataAgreementInstanceSchema
)
from ....patched_protocols.issue_credential.v1_0.routes import (
    SendDataAgreementNegotiationProblemReportRequestSchema
)
from ....v1_0.utils.did.mydata_did import DIDMyData
from ....v1_0.utils.wallet.key_type import KeyType
from ....v1_0.utils.util import comma_separated_str_to_list, get_slices


PAGINATION_PAGE_SIZE = 10


class V10PresentationExchangeListQueryStringSchema(OpenAPISchema):
    &#34;&#34;&#34;Parameters and validators for presentation exchange list query.&#34;&#34;&#34;

    connection_id = fields.UUID(
        description=&#34;Connection identifier&#34;,
        required=False,
        example=UUIDFour.EXAMPLE,  # typically but not necessarily a UUID4
    )
    thread_id = fields.UUID(
        description=&#34;Thread identifier&#34;,
        required=False,
        example=UUIDFour.EXAMPLE,  # typically but not necessarily a UUID4
    )
    role = fields.Str(
        description=&#34;Role assigned in presentation exchange&#34;,
        required=False,
        validate=validate.OneOf(
            [
                getattr(V10PresentationExchange, m)
                for m in vars(V10PresentationExchange)
                if m.startswith(&#34;ROLE_&#34;)
            ]
        ),
    )
    state = fields.Str(
        description=&#34;Presentation exchange state&#34;,
        required=False,
        validate=validate.OneOf(
            [
                getattr(V10PresentationExchange, m)
                for m in vars(V10PresentationExchange)
                if m.startswith(&#34;STATE_&#34;)
            ]
        ),
    )


class V10PresentationExchangeListSchema(OpenAPISchema):
    &#34;&#34;&#34;Result schema for an Aries RFC 37 v1.0 presentation exchange query.&#34;&#34;&#34;

    results = fields.List(
        fields.Nested(V10PresentationExchangeSchema()),
        description=&#34;Aries RFC 37 v1.0 presentation exchange records&#34;,
    )


class V10PresentationProposalRequestSchema(AdminAPIMessageTracingSchema):
    &#34;&#34;&#34;Request schema for sending a presentation proposal admin message.&#34;&#34;&#34;

    connection_id = fields.UUID(
        description=&#34;Connection identifier&#34;, required=True, example=UUIDFour.EXAMPLE
    )
    comment = fields.Str(
        description=&#34;Human-readable comment&#34;, required=False, allow_none=True
    )
    presentation_proposal = fields.Nested(
        PresentationPreviewSchema(), required=True)
    auto_present = fields.Boolean(
        description=(
            &#34;Whether to respond automatically to presentation requests, building &#34;
            &#34;and presenting requested proof&#34;
        ),
        required=False,
        default=False,
    )
    trace = fields.Bool(
        description=&#34;Whether to trace event (default false)&#34;,
        required=False,
        example=False,
    )


class DAIndyProofReqPredSpecRestrictionsSchema(OpenAPISchema):
    &#34;&#34;&#34;Schema for restrictions in attr or pred specifier indy proof request.&#34;&#34;&#34;

    schema_id = fields.String(
        description=&#34;Schema identifier&#34;, required=False, **INDY_SCHEMA_ID
    )
    schema_issuer_did = fields.String(
        description=&#34;Schema issuer (origin) DID&#34;, required=False, **INDY_DID
    )
    schema_name = fields.String(
        example=&#34;transcript&#34;, description=&#34;Schema name&#34;, required=False
    )
    schema_version = fields.String(
        description=&#34;Schema version&#34;, required=False, **INDY_VERSION
    )
    issuer_did = fields.String(
        description=&#34;Credential issuer DID&#34;, required=False, **INDY_DID
    )
    cred_def_id = fields.String(
        description=&#34;Credential definition identifier&#34;,
        required=False,
        **INDY_CRED_DEF_ID,
    )


class DAIndyProofReqNonRevokedSchema(OpenAPISchema):
    &#34;&#34;&#34;Non-revocation times specification in indy proof request.&#34;&#34;&#34;

    fro = fields.Int(
        description=&#34;Earliest epoch of interest for non-revocation proof&#34;,
        required=False,
        data_key=&#34;from&#34;,
        **INT_EPOCH,
    )
    to = fields.Int(
        description=&#34;Latest epoch of interest for non-revocation proof&#34;,
        required=False,
        **INT_EPOCH,
    )

    @validates_schema
    def validate_fields(self, data, **kwargs):
        &#34;&#34;&#34;
        Validate schema fields - must have from, to, or both.

        Args:
            data: The data to validate

        Raises:
            ValidationError: if data has neither from nor to

        &#34;&#34;&#34;
        if not (data.get(&#34;from&#34;) or data.get(&#34;to&#34;)):
            raise ValidationError(
                &#34;Non-revocation interval must have at least one end&#34;, (&#34;fro&#34;,
                                                                       &#34;to&#34;)
            )


class DAIndyProofReqAttrSpecSchema(OpenAPISchema):
    &#34;&#34;&#34;Schema for attribute specification in indy proof request.&#34;&#34;&#34;

    name = fields.String(
        example=&#34;favouriteDrink&#34;, description=&#34;Attribute name&#34;, required=False
    )
    names = fields.List(
        fields.String(example=&#34;age&#34;),
        description=&#34;Attribute name group&#34;,
        required=False,
    )
    restrictions = fields.List(
        fields.Dict(
            keys=fields.Str(
                validate=validate.Regexp(
                    &#34;^schema_id|&#34;
                    &#34;schema_issuer_did|&#34;
                    &#34;schema_name|&#34;
                    &#34;schema_version|&#34;
                    &#34;issuer_did|&#34;
                    &#34;cred_def_id|&#34;
                    &#34;attr::.+::value$&#34;  # indy does not support attr::...::marker here
                ),
                example=&#34;cred_def_id&#34;,  # marshmallow/apispec v3.0 ignores
            ),
            values=fields.Str(example=INDY_CRED_DEF_ID[&#34;example&#34;]),
        ),
        description=(
            &#34;If present, credential must satisfy one of given restrictions: specify &#34;
            &#34;schema_id, schema_issuer_did, schema_name, schema_version, &#34;
            &#34;issuer_did, cred_def_id, and/or attr::&lt;attribute-name&gt;::value &#34;
            &#34;where &lt;attribute-name&gt; represents a credential attribute name&#34;
        ),
        required=False,
    )
    non_revoked = fields.Nested(
        DAIndyProofReqNonRevokedSchema(), required=False)

    @validates_schema
    def validate_fields(self, data, **kwargs):
        &#34;&#34;&#34;
        Validate schema fields.

        Data must have exactly one of name or names; if names then restrictions are
        mandatory.

        Args:
            data: The data to validate

        Raises:
            ValidationError: if data has both or neither of name and names

        &#34;&#34;&#34;
        if (&#34;name&#34; in data) == (&#34;names&#34; in data):
            raise ValidationError(
                &#34;Attribute specification must have either name or names but not both&#34;
            )
        restrictions = data.get(&#34;restrictions&#34;)
        if (&#34;names&#34; in data) and (not restrictions or all(not r for r in restrictions)):
            raise ValidationError(
                &#34;Attribute specification on &#39;names&#39; must have non-empty restrictions&#34;
            )


class DAIndyProofReqPredSpecSchema(OpenAPISchema):
    &#34;&#34;&#34;Schema for predicate specification in indy proof request.&#34;&#34;&#34;

    name = fields.String(
        example=&#34;index&#34;, description=&#34;Attribute name&#34;, required=True)
    p_type = fields.String(
        description=&#34;Predicate type (&#39;&lt;&#39;, &#39;&lt;=&#39;, &#39;&gt;=&#39;, or &#39;&gt;&#39;)&#34;,
        required=True,
        **INDY_PREDICATE,
    )
    p_value = fields.Integer(description=&#34;Threshold value&#34;, required=True)
    restrictions = fields.List(
        fields.Nested(DAIndyProofReqPredSpecRestrictionsSchema()),
        description=&#34;If present, credential must satisfy one of given restrictions&#34;,
        required=False,
    )
    non_revoked = fields.Nested(
        DAIndyProofReqNonRevokedSchema(), required=False)


class DAIndyProofRequestSchema(OpenAPISchema):
    &#34;&#34;&#34;Schema for indy proof request.&#34;&#34;&#34;

    nonce = fields.String(description=&#34;Nonce&#34;,
                          required=False, example=&#34;1234567890&#34;)
    name = fields.String(
        description=&#34;Proof request name&#34;,
        required=False,
        example=&#34;Proof request&#34;,
        default=&#34;Proof request&#34;,
    )
    version = fields.String(
        description=&#34;Proof request version&#34;,
        required=False,
        default=&#34;1.0&#34;,
        **INDY_VERSION,
    )
    requested_attributes = fields.Dict(
        description=(&#34;Requested attribute specifications of proof request&#34;),
        required=True,
        # marshmallow/apispec v3.0 ignores
        keys=fields.Str(example=&#34;0_attr_uuid&#34;),
        values=fields.Nested(DAIndyProofReqAttrSpecSchema()),
    )
    requested_predicates = fields.Dict(
        description=(&#34;Requested predicate specifications of proof request&#34;),
        required=True,
        # marshmallow/apispec v3.0 ignores
        keys=fields.Str(example=&#34;0_age_GE_uuid&#34;),
        values=fields.Nested(DAIndyProofReqPredSpecSchema()),
    )
    non_revoked = fields.Nested(
        DAIndyProofReqNonRevokedSchema(), required=False)


class V10PresentationCreateRequestRequestSchema(AdminAPIMessageTracingSchema):
    &#34;&#34;&#34;Request schema for creating a proof request free of any connection.&#34;&#34;&#34;

    proof_request = fields.Nested(DAIndyProofRequestSchema(), required=True)
    comment = fields.Str(required=False, allow_none=True)
    trace = fields.Bool(
        description=&#34;Whether to trace event (default false)&#34;,
        required=False,
        example=False,
    )


class V10PresentationSendRequestRequestSchema(
    V10PresentationCreateRequestRequestSchema
):
    &#34;&#34;&#34;Request schema for sending a proof request on a connection.&#34;&#34;&#34;

    connection_id = fields.UUID(
        description=&#34;Connection identifier&#34;, required=True, example=UUIDFour.EXAMPLE
    )


class IndyRequestedCredsRequestedAttrSchema(OpenAPISchema):
    &#34;&#34;&#34;Schema for requested attributes within indy requested credentials structure.&#34;&#34;&#34;

    cred_id = fields.Str(
        example=&#34;3fa85f64-5717-4562-b3fc-2c963f66afa6&#34;,
        description=(
            &#34;Wallet credential identifier (typically but not necessarily a UUID)&#34;
        ),
        required=True,
    )
    revealed = fields.Bool(
        description=&#34;Whether to reveal attribute in proof&#34;, required=True
    )
    timestamp = fields.Int(
        description=&#34;Epoch timestamp of interest for non-revocation proof&#34;,
        required=False,
        **INT_EPOCH,
    )


class IndyRequestedCredsRequestedPredSchema(OpenAPISchema):
    &#34;&#34;&#34;Schema for requested predicates within indy requested credentials structure.&#34;&#34;&#34;

    cred_id = fields.Str(
        description=(
            &#34;Wallet credential identifier (typically but not necessarily a UUID)&#34;
        ),
        example=&#34;3fa85f64-5717-4562-b3fc-2c963f66afa6&#34;,
        required=True,
    )
    timestamp = fields.Int(
        description=&#34;Epoch timestamp of interest for non-revocation proof&#34;,
        required=False,
        **INT_EPOCH,
    )


class V10PresentationRequestSchema(AdminAPIMessageTracingSchema):
    &#34;&#34;&#34;Request schema for sending a presentation.&#34;&#34;&#34;

    self_attested_attributes = fields.Dict(
        description=(&#34;Self-attested attributes to build into proof&#34;),
        required=True,
        # marshmallow/apispec v3.0 ignores
        keys=fields.Str(example=&#34;attr_name&#34;),
        values=fields.Str(
            example=&#34;self_attested_value&#34;,
            description=(
                &#34;Self-attested attribute values to use in requested-credentials &#34;
                &#34;structure for proof construction&#34;
            ),
        ),
    )
    requested_attributes = fields.Dict(
        description=(
            &#34;Nested object mapping proof request attribute referents to &#34;
            &#34;requested-attribute specifiers&#34;
        ),
        required=True,
        # marshmallow/apispec v3.0 ignores
        keys=fields.Str(example=&#34;attr_referent&#34;),
        values=fields.Nested(IndyRequestedCredsRequestedAttrSchema()),
    )
    requested_predicates = fields.Dict(
        description=(
            &#34;Nested object mapping proof request predicate referents to &#34;
            &#34;requested-predicate specifiers&#34;
        ),
        required=True,
        # marshmallow/apispec v3.0 ignores
        keys=fields.Str(example=&#34;pred_referent&#34;),
        values=fields.Nested(IndyRequestedCredsRequestedPredSchema()),
    )
    trace = fields.Bool(
        description=&#34;Whether to trace event (default false)&#34;,
        required=False,
        example=False,
    )


class CredentialsFetchQueryStringSchema(OpenAPISchema):
    &#34;&#34;&#34;Parameters and validators for credentials fetch request query string.&#34;&#34;&#34;

    referent = fields.Str(
        description=&#34;Proof request referents of interest, comma-separated&#34;,
        required=False,
        example=&#34;1_name_uuid,2_score_uuid&#34;,
    )
    start = fields.Int(description=&#34;Start index&#34;, required=False, **WHOLE_NUM)
    count = fields.Int(
        description=&#34;Maximum number to retrieve&#34;, required=False, **NATURAL_NUM
    )
    extra_query = fields.Str(
        description=&#34;(JSON) object mapping referents to extra WQL queries&#34;,
        required=False,
        **INDY_EXTRA_WQL,
    )


class PresExIdMatchInfoSchema(OpenAPISchema):
    &#34;&#34;&#34;Path parameters and validators for request taking presentation exchange id.&#34;&#34;&#34;

    pres_ex_id = fields.Str(
        description=&#34;Presentation exchange identifier&#34;, required=True, **UUID4
    )


class SendPresentationRequestForDataAgreementRequestSchema(OpenAPISchema):
    &#34;&#34;&#34;Request schema for sending a presentation request for a data agreement.&#34;&#34;&#34;

    # Connection identifier
    connection_id = fields.UUID(required=True)

    # Data agreement template identifier
    template_id = fields.Str(required=True)


@docs(tags=[&#34;present-proof&#34;], summary=&#34;Fetch all present-proof exchange records&#34;)
@querystring_schema(V10PresentationExchangeListQueryStringSchema)
@response_schema(V10PresentationExchangeListSchema(), 200)
async def presentation_exchange_list(request: web.BaseRequest):
    &#34;&#34;&#34;
    Request handler for searching presentation exchange records.

    Args:
        request: aiohttp request object

    Returns:
        The presentation exchange list response

    &#34;&#34;&#34;
    context = request.app[&#34;request_context&#34;]
    tag_filter = {}
    if &#34;thread_id&#34; in request.query and request.query[&#34;thread_id&#34;] != &#34;&#34;:
        tag_filter[&#34;thread_id&#34;] = request.query[&#34;thread_id&#34;]
    post_filter = {
        k: request.query[k]
        for k in (&#34;connection_id&#34;, &#34;role&#34;, &#34;state&#34;)
        if request.query.get(k, &#34;&#34;) != &#34;&#34;
    }

    try:
        records = await V10PresentationExchange.query(context, tag_filter, post_filter)
        results = [record.serialize() for record in records]
    except (StorageError, BaseModelError) as err:
        raise web.HTTPBadRequest(reason=err.roll_up) from err

    return web.json_response({&#34;results&#34;: results})


@docs(tags=[&#34;present-proof&#34;], summary=&#34;Fetch a single presentation exchange record&#34;)
@match_info_schema(PresExIdMatchInfoSchema())
@response_schema(V10PresentationExchangeSchema(), 200)
async def presentation_exchange_retrieve(request: web.BaseRequest):
    &#34;&#34;&#34;
    Request handler for fetching a single presentation exchange record.

    Args:
        request: aiohttp request object

    Returns:
        The presentation exchange record response

    &#34;&#34;&#34;
    context = request.app[&#34;request_context&#34;]
    outbound_handler = request.app[&#34;outbound_message_router&#34;]

    presentation_exchange_id = request.match_info[&#34;pres_ex_id&#34;]
    pres_ex_record = None
    try:
        pres_ex_record = await V10PresentationExchange.retrieve_by_id(
            context, presentation_exchange_id
        )
        result = pres_ex_record.serialize()
    except StorageNotFoundError as err:
        raise web.HTTPNotFound(reason=err.roll_up) from err
    except (BaseModelError, StorageError) as err:
        await internal_error(err, web.HTTPBadRequest, pres_ex_record, outbound_handler)

    return web.json_response(result)


@docs(
    tags=[&#34;present-proof&#34;],
    summary=&#34;Fetch credentials for a presentation request from wallet&#34;,
)
@match_info_schema(PresExIdMatchInfoSchema())
@querystring_schema(CredentialsFetchQueryStringSchema())
async def presentation_exchange_credentials_list(request: web.BaseRequest):
    &#34;&#34;&#34;
    Request handler for searching applicable credential records.

    Args:
        request: aiohttp request object

    Returns:
        The credential list response

    &#34;&#34;&#34;
    context = request.app[&#34;request_context&#34;]
    outbound_handler = request.app[&#34;outbound_message_router&#34;]

    presentation_exchange_id = request.match_info[&#34;pres_ex_id&#34;]
    referents = request.query.get(&#34;referent&#34;)
    presentation_referents = (
        (r.strip() for r in referents.split(&#34;,&#34;)) if referents else ()
    )

    try:
        pres_ex_record = await V10PresentationExchange.retrieve_by_id(
            context, presentation_exchange_id
        )
    except StorageNotFoundError as err:
        raise web.HTTPNotFound(reason=err.roll_up) from err

    start = request.query.get(&#34;start&#34;)
    count = request.query.get(&#34;count&#34;)

    # url encoded json extra_query
    encoded_extra_query = request.query.get(&#34;extra_query&#34;) or &#34;{}&#34;
    extra_query = json.loads(encoded_extra_query)

    # defaults
    start = int(start) if isinstance(start, str) else 0
    count = int(count) if isinstance(count, str) else 10

    holder: BaseHolder = await context.inject(BaseHolder)
    try:
        credentials = await holder.get_credentials_for_presentation_request_by_referent(
            pres_ex_record.presentation_request,
            presentation_referents,
            start,
            count,
            extra_query,
        )
    except HolderError as err:
        await internal_error(err, web.HTTPBadRequest, pres_ex_record, outbound_handler)

    pres_ex_record.log_state(
        context,
        &#34;Retrieved presentation credentials&#34;,
        {
            &#34;presentation_exchange_id&#34;: presentation_exchange_id,
            &#34;referents&#34;: presentation_referents,
            &#34;extra_query&#34;: extra_query,
            &#34;credentials&#34;: credentials,
        },
    )
    return web.json_response(credentials)


@docs(tags=[&#34;present-proof&#34;], summary=&#34;Sends a presentation proposal&#34;)
@request_schema(V10PresentationProposalRequestSchema())
@response_schema(V10PresentationExchangeSchema(), 200)
async def presentation_exchange_send_proposal(request: web.BaseRequest):
    &#34;&#34;&#34;
    Request handler for sending a presentation proposal.

    Args:
        request: aiohttp request object

    Returns:
        The presentation exchange details

    &#34;&#34;&#34;
    r_time = get_timer()

    context = request.app[&#34;request_context&#34;]
    outbound_handler = request.app[&#34;outbound_message_router&#34;]

    body = await request.json()

    comment = body.get(&#34;comment&#34;)
    connection_id = body.get(&#34;connection_id&#34;)

    # Aries RFC 37 calls it a proposal in the proposal struct but it&#39;s of type preview
    presentation_preview = body.get(&#34;presentation_proposal&#34;)
    connection_record = None
    try:
        connection_record = await ConnectionRecord.retrieve_by_id(
            context, connection_id
        )
        presentation_proposal_message = PresentationProposal(
            comment=comment,
            presentation_proposal=PresentationPreview.deserialize(
                presentation_preview),
        )
    except (BaseModelError, StorageError) as err:
        await internal_error(
            err, web.HTTPBadRequest, connection_record, outbound_handler
        )

    if not connection_record.is_ready:
        raise web.HTTPForbidden(reason=f&#34;Connection {connection_id} not ready&#34;)

    trace_msg = body.get(&#34;trace&#34;)
    presentation_proposal_message.assign_trace_decorator(
        context.settings,
        trace_msg,
    )
    auto_present = body.get(
        &#34;auto_present&#34;, context.settings.get(
            &#34;debug.auto_respond_presentation_request&#34;)
    )

    presentation_manager = PresentationManager(context)
    pres_ex_record = None
    try:
        pres_ex_record = await presentation_manager.create_exchange_for_proposal(
            connection_id=connection_id,
            presentation_proposal_message=presentation_proposal_message,
            auto_present=auto_present,
        )
        result = pres_ex_record.serialize()
    except (BaseModelError, StorageError) as err:
        await internal_error(
            err,
            web.HTTPBadRequest,
            pres_ex_record or connection_record,
            outbound_handler,
        )

    await outbound_handler(presentation_proposal_message, connection_id=connection_id)

    trace_event(
        context.settings,
        presentation_proposal_message,
        outcome=&#34;presentation_exchange_propose.END&#34;,
        perf_counter=r_time,
    )

    return web.json_response(result)


@docs(
    tags=[&#34;present-proof&#34;],
    summary=&#34;&#34;&#34;
    Creates a presentation request not bound to any proposal or existing connection
    &#34;&#34;&#34;,
)
@request_schema(V10PresentationCreateRequestRequestSchema())
@response_schema(V10PresentationExchangeSchema(), 200)
async def presentation_exchange_create_request(request: web.BaseRequest):
    &#34;&#34;&#34;
    Request handler for creating a free presentation request.

    The presentation request will not be bound to any proposal
    or existing connection.

    Args:
        request: aiohttp request object

    Returns:
        The presentation exchange details

    &#34;&#34;&#34;
    r_time = get_timer()

    context = request.app[&#34;request_context&#34;]
    outbound_handler = request.app[&#34;outbound_message_router&#34;]

    body = await request.json()

    comment = body.get(&#34;comment&#34;)
    indy_proof_request = body.get(&#34;proof_request&#34;)
    if not indy_proof_request.get(&#34;nonce&#34;):
        indy_proof_request[&#34;nonce&#34;] = await generate_pr_nonce()

    presentation_request_message = PresentationRequest(
        comment=comment,
        request_presentations_attach=[
            AttachDecorator.from_indy_dict(
                indy_dict=indy_proof_request,
                ident=ATTACH_DECO_IDS[PRESENTATION_REQUEST],
            )
        ],
    )
    trace_msg = body.get(&#34;trace&#34;)
    presentation_request_message.assign_trace_decorator(
        context.settings,
        trace_msg,
    )

    presentation_manager = PresentationManager(context)
    pres_ex_record = None
    try:
        (pres_ex_record) = await presentation_manager.create_exchange_for_request(
            connection_id=None,
            presentation_request_message=presentation_request_message,
        )
        result = pres_ex_record.serialize()
    except (BaseModelError, StorageError) as err:
        await internal_error(err, web.HTTPBadRequest, pres_ex_record, outbound_handler)

    await outbound_handler(presentation_request_message, connection_id=None)

    trace_event(
        context.settings,
        presentation_request_message,
        outcome=&#34;presentation_exchange_create_request.END&#34;,
        perf_counter=r_time,
    )

    return web.json_response(result)


@docs(
    tags=[&#34;present-proof&#34;],
    summary=&#34;Sends a free presentation request not bound to any proposal&#34;,
)
@request_schema(V10PresentationSendRequestRequestSchema())
@response_schema(V10PresentationExchangeSchema(), 200)
async def presentation_exchange_send_free_request(request: web.BaseRequest):
    &#34;&#34;&#34;
    Request handler for sending a presentation request free from any proposal.

    Args:
        request: aiohttp request object

    Returns:
        The presentation exchange details

    &#34;&#34;&#34;
    r_time = get_timer()

    context = request.app[&#34;request_context&#34;]
    outbound_handler = request.app[&#34;outbound_message_router&#34;]

    body = await request.json()

    connection_id = body.get(&#34;connection_id&#34;)
    try:
        connection_record = await ConnectionRecord.retrieve_by_id(
            context, connection_id
        )
    except StorageNotFoundError as err:
        raise web.HTTPBadRequest(reason=err.roll_up) from err

    if not connection_record.is_ready:
        raise web.HTTPForbidden(reason=f&#34;Connection {connection_id} not ready&#34;)

    comment = body.get(&#34;comment&#34;)
    indy_proof_request = body.get(&#34;proof_request&#34;)
    if not indy_proof_request.get(&#34;nonce&#34;):
        indy_proof_request[&#34;nonce&#34;] = await generate_pr_nonce()

    presentation_request_message = PresentationRequest(
        comment=comment,
        request_presentations_attach=[
            AttachDecorator.from_indy_dict(
                indy_dict=indy_proof_request,
                ident=ATTACH_DECO_IDS[PRESENTATION_REQUEST],
            )
        ],
    )
    trace_msg = body.get(&#34;trace&#34;)
    presentation_request_message.assign_trace_decorator(
        context.settings,
        trace_msg,
    )

    presentation_manager = PresentationManager(context)
    pres_ex_record = None
    try:
        (pres_ex_record) = await presentation_manager.create_exchange_for_request(
            connection_id=connection_id,
            presentation_request_message=presentation_request_message,
        )
        result = pres_ex_record.serialize()
    except (BaseModelError, StorageError) as err:
        await internal_error(
            err,
            web.HTTPBadRequest,
            pres_ex_record or connection_record,
            outbound_handler,
        )

    await outbound_handler(presentation_request_message, connection_id=connection_id)

    trace_event(
        context.settings,
        presentation_request_message,
        outcome=&#34;presentation_exchange_send_request.END&#34;,
        perf_counter=r_time,
    )

    return web.json_response(result)


@docs(
    tags=[&#34;present-proof&#34;],
    summary=&#34;Sends a presentation request in reference to a proposal&#34;,
)
@match_info_schema(PresExIdMatchInfoSchema())
@request_schema(V10PresentationSendRequestRequestSchema())
@response_schema(V10PresentationExchangeSchema(), 200)
async def presentation_exchange_send_bound_request(request: web.BaseRequest):
    &#34;&#34;&#34;
    Request handler for sending a presentation request free from any proposal.

    Args:
        request: aiohttp request object

    Returns:
        The presentation exchange details

    &#34;&#34;&#34;
    r_time = get_timer()

    context = request.app[&#34;request_context&#34;]
    outbound_handler = request.app[&#34;outbound_message_router&#34;]

    presentation_exchange_id = request.match_info[&#34;pres_ex_id&#34;]
    pres_ex_record = await V10PresentationExchange.retrieve_by_id(
        context, presentation_exchange_id
    )
    if pres_ex_record.state != (V10PresentationExchange.STATE_PROPOSAL_RECEIVED):
        raise web.HTTPBadRequest(
            reason=(
                f&#34;Presentation exchange {presentation_exchange_id} &#34;
                f&#34;in {pres_ex_record.state} state &#34;
                f&#34;(must be {V10PresentationExchange.STATE_PROPOSAL_RECEIVED})&#34;
            )
        )
    body = await request.json()

    connection_id = body.get(&#34;connection_id&#34;)
    try:
        connection_record = await ConnectionRecord.retrieve_by_id(
            context, connection_id
        )
    except StorageError as err:
        raise web.HTTPBadRequest(reason=err.roll_up) from err

    if not connection_record.is_ready:
        raise web.HTTPForbidden(reason=f&#34;Connection {connection_id} not ready&#34;)

    presentation_manager = PresentationManager(context)
    try:
        (
            pres_ex_record,
            presentation_request_message,
        ) = await presentation_manager.create_bound_request(pres_ex_record)
        result = pres_ex_record.serialize()
    except (BaseModelError, StorageError) as err:
        await internal_error(
            err,
            web.HTTPBadRequest,
            pres_ex_record or connection_record,
            outbound_handler,
        )

    trace_msg = body.get(&#34;trace&#34;)
    presentation_request_message.assign_trace_decorator(
        context.settings,
        trace_msg,
    )
    await outbound_handler(presentation_request_message, connection_id=connection_id)

    trace_event(
        context.settings,
        presentation_request_message,
        outcome=&#34;presentation_exchange_send_request.END&#34;,
        perf_counter=r_time,
    )

    return web.json_response(result)


@docs(tags=[&#34;present-proof&#34;], summary=&#34;Sends a proof presentation&#34;)
@match_info_schema(PresExIdMatchInfoSchema())
@request_schema(V10PresentationRequestSchema())
@response_schema(V10PresentationExchangeSchema())
async def presentation_exchange_send_presentation(request: web.BaseRequest):
    &#34;&#34;&#34;
    Request handler for sending a presentation.

    Args:
        request: aiohttp request object

    Returns:
        The presentation exchange details

    &#34;&#34;&#34;
    r_time = get_timer()

    context = request.app[&#34;request_context&#34;]
    outbound_handler = request.app[&#34;outbound_message_router&#34;]
    presentation_exchange_id = request.match_info[&#34;pres_ex_id&#34;]
    pres_ex_record = await V10PresentationExchange.retrieve_by_id(
        context, presentation_exchange_id
    )
    if pres_ex_record.state != (V10PresentationExchange.STATE_REQUEST_RECEIVED):
        raise web.HTTPBadRequest(
            reason=(
                f&#34;Presentation exchange {presentation_exchange_id} &#34;
                f&#34;in {pres_ex_record.state} state &#34;
                f&#34;(must be {V10PresentationExchange.STATE_REQUEST_RECEIVED})&#34;
            )
        )

    body = await request.json()

    connection_id = pres_ex_record.connection_id
    try:
        connection_record = await ConnectionRecord.retrieve_by_id(
            context, connection_id
        )
    except StorageNotFoundError as err:
        raise web.HTTPBadRequest(reason=err.roll_up) from err

    if not connection_record.is_ready:
        raise web.HTTPForbidden(reason=f&#34;Connection {connection_id} not ready&#34;)

    presentation_manager = PresentationManager(context)
    try:
        (
            pres_ex_record,
            presentation_message,
        ) = await presentation_manager.create_presentation(
            pres_ex_record,
            {
                &#34;self_attested_attributes&#34;: body.get(&#34;self_attested_attributes&#34;),
                &#34;requested_attributes&#34;: body.get(&#34;requested_attributes&#34;),
                &#34;requested_predicates&#34;: body.get(&#34;requested_predicates&#34;),
            },
            comment=body.get(&#34;comment&#34;),
        )

        # Initialize ADA manager
        manager = V2ADAManager(context)

        # Initialize ADA manager.
        manager = V2ADAManager(context)

        # Create data agreement accept message.
        accept_message = await manager.build_data_agreement_accept_for_data_ex_record(
            connection_record,
            pres_ex_record
        )

        # Update presentation message with data agreement context decorator
        presentation_message._decorators[&#34;data-agreement-context&#34;] = \
            DataAgreementContextDecorator(
            message_type=&#34;protocol&#34;,
            message=accept_message.serialize()
        )

        result = pres_ex_record.serialize()
    except (
        BaseModelError,
        HolderError,
        LedgerError,
        StorageError,
        WalletNotFoundError,
    ) as err:
        await internal_error(
            err,
            web.HTTPBadRequest,
            pres_ex_record or connection_record,
            outbound_handler,
        )

    trace_msg = body.get(&#34;trace&#34;)
    presentation_message.assign_trace_decorator(
        context.settings,
        trace_msg,
    )
    await outbound_handler(presentation_message, connection_id=connection_id)

    trace_event(
        context.settings,
        presentation_message,
        outcome=&#34;presentation_exchange_send_request.END&#34;,
        perf_counter=r_time,
    )

    return web.json_response(result)


@docs(tags=[&#34;present-proof&#34;], summary=&#34;Verify a received presentation&#34;)
@match_info_schema(PresExIdMatchInfoSchema())
@response_schema(V10PresentationExchangeSchema())
async def presentation_exchange_verify_presentation(request: web.BaseRequest):
    &#34;&#34;&#34;
    Request handler for verifying a presentation request.

    Args:
        request: aiohttp request object

    Returns:
        The presentation exchange details

    &#34;&#34;&#34;
    r_time = get_timer()

    context = request.app[&#34;request_context&#34;]
    outbound_handler = request.app[&#34;outbound_message_router&#34;]

    presentation_exchange_id = request.match_info[&#34;pres_ex_id&#34;]

    pres_ex_record = await V10PresentationExchange.retrieve_by_id(
        context, presentation_exchange_id
    )
    if pres_ex_record.state != (V10PresentationExchange.STATE_PRESENTATION_RECEIVED):
        raise web.HTTPBadRequest(
            reason=(
                f&#34;Presentation exchange {presentation_exchange_id} &#34;
                f&#34;in {pres_ex_record.state} state &#34;
                f&#34;(must be {V10PresentationExchange.STATE_PRESENTATION_RECEIVED})&#34;
            )
        )

    connection_id = pres_ex_record.connection_id

    try:
        connection_record = await ConnectionRecord.retrieve_by_id(
            context, connection_id
        )
    except StorageError as err:
        raise web.HTTPBadRequest(reason=err.roll_up) from err

    if not connection_record.is_ready:
        raise web.HTTPForbidden(reason=f&#34;Connection {connection_id} not ready&#34;)

    presentation_manager = PresentationManager(context)
    try:
        pres_ex_record = await presentation_manager.verify_presentation(pres_ex_record)
        result = pres_ex_record.serialize()
    except (LedgerError, BaseModelError) as err:
        await internal_error(err, web.HTTPBadRequest, pres_ex_record, outbound_handler)

    trace_event(
        context.settings,
        pres_ex_record,
        outcome=&#34;presentation_exchange_verify.END&#34;,
        perf_counter=r_time,
    )

    return web.json_response(result)


@docs(tags=[&#34;present-proof&#34;], summary=&#34;Remove an existing presentation exchange record&#34;)
@match_info_schema(PresExIdMatchInfoSchema())
async def presentation_exchange_remove(request: web.BaseRequest):
    &#34;&#34;&#34;
    Request handler for removing a presentation exchange record.

    Args:
        request: aiohttp request object

    &#34;&#34;&#34;
    context = request.app[&#34;request_context&#34;]
    outbound_handler = request.app[&#34;outbound_message_router&#34;]

    presentation_exchange_id = request.match_info[&#34;pres_ex_id&#34;]
    pres_ex_record = None
    try:
        pres_ex_record: V10PresentationExchange = await V10PresentationExchange.retrieve_by_id(
            context, presentation_exchange_id
        )
        await pres_ex_record.delete_record(context)

        # Initialize ADA manager
        manager = V2ADAManager(context)

        # Delete data agreement instance
        await manager.delete_da_instance_by_data_ex_id(pres_ex_record.presentation_exchange_id)

    except StorageNotFoundError as err:
        await internal_error(err, web.HTTPNotFound, pres_ex_record, outbound_handler)
    except StorageError as err:
        await internal_error(err, web.HTTPBadRequest, pres_ex_record, outbound_handler)

    return web.json_response({})


@docs(tags=[&#34;present-proof&#34;],
      summary=&#34;Send a presentation request in reference to a data agreement&#34;)
@request_schema(SendPresentationRequestForDataAgreementRequestSchema())
async def send_presentation_request_for_data_agreement(request: web.BaseRequest):
    &#34;&#34;&#34;
    Sent a presentation request in reference to a data agreement.

    Args:
        request: aiohttp request object
    &#34;&#34;&#34;

    # Retrieve context
    context = request.app[&#34;request_context&#34;]

    # Outbound message handler
    outbound_handler = request.app[&#34;outbound_message_router&#34;]

    # Request payload
    body = await request.json()

    # Data agreement template identifier
    template_id = body.get(&#34;template_id&#34;)

    # Connection identifier
    connection_id = body.get(&#34;connection_id&#34;)

    # Fetch the connection record
    connection_record: ConnectionRecord = await ConnectionRecord.retrieve_by_id(
        context,
        connection_id
    )

    if not connection_record.is_ready:
        raise web.HTTPForbidden(reason=f&#34;Connection {connection_id} not ready&#34;)

    # Initialise ADA manager
    manager = V2ADAManager(context)

    # Fetch data agreement template
    template: DataAgreementTemplateRecord = \
        await DataAgreementTemplateRecord.latest_published_template_by_id(
            context, template_id
        )

    if not template:
        raise web.HTTPException(reason=&#34;Data agreement template not found.&#34;)

    if template.method_of_use != DataAgreementTemplateRecord.METHOD_OF_USE_DATA_USING_SERVICE:
        raise web.HTTPException(reason=&#34;Data agreement method of use must be data-using-service.&#34;)

    # Construct presentation request
    preset_presentation_request = template.presentation_request
    comment = preset_presentation_request.pop(&#34;comment&#34;)
    if not preset_presentation_request.get(&#34;nonce&#34;):
        preset_presentation_request[&#34;nonce&#34;] = await generate_pr_nonce()

    presentation_request = PresentationRequest(
        comment=comment,
        request_presentations_attach=[
            AttachDecorator.from_indy_dict(
                indy_dict=preset_presentation_request,
                ident=ATTACH_DECO_IDS[PRESENTATION_REQUEST],
            )
        ],
    )

    # Construct presentation exchange record
    presentation_manager = PresentationManager(context)
    pres_ex_record = None
    try:
        (pres_ex_record) = await presentation_manager.create_exchange_for_request(
            connection_id=connection_id,
            presentation_request_message=presentation_request,
        )
        result = pres_ex_record.serialize()
    except (BaseModelError, StorageError) as err:
        await internal_error(
            err,
            web.HTTPBadRequest,
            pres_ex_record or connection_record,
            outbound_handler,
        )

    # Build data agreement offer message
    da_offer_message = await manager.build_data_agreement_offer_for_presentation_exchange(
        template_id,
        connection_record,
        pres_ex_record
    )

    # Add data agreement context decorator
    presentation_request._decorators[&#34;data-agreement-context&#34;] = \
        DataAgreementContextDecorator(
        message_type=&#34;protocol&#34;,
        message=da_offer_message.serialize()
    )

    pres_ex_record.presentation_request_dict = presentation_request.serialize()
    await pres_ex_record.save(context)

    result = pres_ex_record.serialize()

    await outbound_handler(presentation_request, connection_id=connection_id)

    return web.json_response(result)


async def register(app: web.Application):
    &#34;&#34;&#34;Register routes.&#34;&#34;&#34;

    app.add_routes(
        [
            web.get(
                &#34;/present-proof/records&#34;, presentation_exchange_list, allow_head=False
            ),
            web.get(
                &#34;/present-proof/records/{pres_ex_id}&#34;,
                presentation_exchange_retrieve,
                allow_head=False,
            ),
            web.get(
                &#34;/present-proof/records/{pres_ex_id}/credentials&#34;,
                presentation_exchange_credentials_list,
                allow_head=False,
            ),
            web.post(
                &#34;/present-proof/send-proposal&#34;,
                presentation_exchange_send_proposal,
            ),
            web.post(
                &#34;/present-proof/create-request&#34;,
                presentation_exchange_create_request,
            ),
            web.post(
                &#34;/present-proof/send-request&#34;,
                presentation_exchange_send_free_request,
            ),
            web.post(
                &#34;/present-proof/records/{pres_ex_id}/send-request&#34;,
                presentation_exchange_send_bound_request,
            ),
            web.post(
                &#34;/present-proof/records/{pres_ex_id}/send-presentation&#34;,
                presentation_exchange_send_presentation,
            ),
            web.post(
                &#34;/present-proof/records/{pres_ex_id}/verify-presentation&#34;,
                presentation_exchange_verify_presentation,
            ),
            web.delete(
                &#34;/present-proof/records/{pres_ex_id}&#34;,
                presentation_exchange_remove,
            ),
            web.post(
                &#34;/present-proof/data-agreement-negotiation/offer&#34;,
                send_presentation_request_for_data_agreement,
            )
        ]
    )


def post_process_routes(app: web.Application):
    &#34;&#34;&#34;Amend swagger API.&#34;&#34;&#34;

    # Add top-level tags description
    if &#34;tags&#34; not in app._state[&#34;swagger_dict&#34;]:
        app._state[&#34;swagger_dict&#34;][&#34;tags&#34;] = []
    app._state[&#34;swagger_dict&#34;][&#34;tags&#34;].append(
        {
            &#34;name&#34;: &#34;present-proof&#34;,
            &#34;description&#34;: &#34;Proof presentation&#34;,
            &#34;externalDocs&#34;: {&#34;description&#34;: &#34;Specification&#34;, &#34;url&#34;: SPEC_URI},
        }
    )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.routes.post_process_routes"><code class="name flex">
<span>def <span class="ident">post_process_routes</span></span>(<span>app: aiohttp.web_app.Application)</span>
</code></dt>
<dd>
<div class="desc"><p>Amend swagger API.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def post_process_routes(app: web.Application):
    &#34;&#34;&#34;Amend swagger API.&#34;&#34;&#34;

    # Add top-level tags description
    if &#34;tags&#34; not in app._state[&#34;swagger_dict&#34;]:
        app._state[&#34;swagger_dict&#34;][&#34;tags&#34;] = []
    app._state[&#34;swagger_dict&#34;][&#34;tags&#34;].append(
        {
            &#34;name&#34;: &#34;present-proof&#34;,
            &#34;description&#34;: &#34;Proof presentation&#34;,
            &#34;externalDocs&#34;: {&#34;description&#34;: &#34;Specification&#34;, &#34;url&#34;: SPEC_URI},
        }
    )</code></pre>
</details>
</dd>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.routes.presentation_exchange_create_request"><code class="name flex">
<span>async def <span class="ident">presentation_exchange_create_request</span></span>(<span>request: aiohttp.web_request.BaseRequest)</span>
</code></dt>
<dd>
<div class="desc"><p>Request handler for creating a free presentation request.</p>
<p>The presentation request will not be bound to any proposal
or existing connection.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>request</code></strong></dt>
<dd>aiohttp request object</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The presentation exchange details</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@docs(
    tags=[&#34;present-proof&#34;],
    summary=&#34;&#34;&#34;
    Creates a presentation request not bound to any proposal or existing connection
    &#34;&#34;&#34;,
)
@request_schema(V10PresentationCreateRequestRequestSchema())
@response_schema(V10PresentationExchangeSchema(), 200)
async def presentation_exchange_create_request(request: web.BaseRequest):
    &#34;&#34;&#34;
    Request handler for creating a free presentation request.

    The presentation request will not be bound to any proposal
    or existing connection.

    Args:
        request: aiohttp request object

    Returns:
        The presentation exchange details

    &#34;&#34;&#34;
    r_time = get_timer()

    context = request.app[&#34;request_context&#34;]
    outbound_handler = request.app[&#34;outbound_message_router&#34;]

    body = await request.json()

    comment = body.get(&#34;comment&#34;)
    indy_proof_request = body.get(&#34;proof_request&#34;)
    if not indy_proof_request.get(&#34;nonce&#34;):
        indy_proof_request[&#34;nonce&#34;] = await generate_pr_nonce()

    presentation_request_message = PresentationRequest(
        comment=comment,
        request_presentations_attach=[
            AttachDecorator.from_indy_dict(
                indy_dict=indy_proof_request,
                ident=ATTACH_DECO_IDS[PRESENTATION_REQUEST],
            )
        ],
    )
    trace_msg = body.get(&#34;trace&#34;)
    presentation_request_message.assign_trace_decorator(
        context.settings,
        trace_msg,
    )

    presentation_manager = PresentationManager(context)
    pres_ex_record = None
    try:
        (pres_ex_record) = await presentation_manager.create_exchange_for_request(
            connection_id=None,
            presentation_request_message=presentation_request_message,
        )
        result = pres_ex_record.serialize()
    except (BaseModelError, StorageError) as err:
        await internal_error(err, web.HTTPBadRequest, pres_ex_record, outbound_handler)

    await outbound_handler(presentation_request_message, connection_id=None)

    trace_event(
        context.settings,
        presentation_request_message,
        outcome=&#34;presentation_exchange_create_request.END&#34;,
        perf_counter=r_time,
    )

    return web.json_response(result)</code></pre>
</details>
</dd>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.routes.presentation_exchange_credentials_list"><code class="name flex">
<span>async def <span class="ident">presentation_exchange_credentials_list</span></span>(<span>request: aiohttp.web_request.BaseRequest)</span>
</code></dt>
<dd>
<div class="desc"><p>Request handler for searching applicable credential records.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>request</code></strong></dt>
<dd>aiohttp request object</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The credential list response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@docs(
    tags=[&#34;present-proof&#34;],
    summary=&#34;Fetch credentials for a presentation request from wallet&#34;,
)
@match_info_schema(PresExIdMatchInfoSchema())
@querystring_schema(CredentialsFetchQueryStringSchema())
async def presentation_exchange_credentials_list(request: web.BaseRequest):
    &#34;&#34;&#34;
    Request handler for searching applicable credential records.

    Args:
        request: aiohttp request object

    Returns:
        The credential list response

    &#34;&#34;&#34;
    context = request.app[&#34;request_context&#34;]
    outbound_handler = request.app[&#34;outbound_message_router&#34;]

    presentation_exchange_id = request.match_info[&#34;pres_ex_id&#34;]
    referents = request.query.get(&#34;referent&#34;)
    presentation_referents = (
        (r.strip() for r in referents.split(&#34;,&#34;)) if referents else ()
    )

    try:
        pres_ex_record = await V10PresentationExchange.retrieve_by_id(
            context, presentation_exchange_id
        )
    except StorageNotFoundError as err:
        raise web.HTTPNotFound(reason=err.roll_up) from err

    start = request.query.get(&#34;start&#34;)
    count = request.query.get(&#34;count&#34;)

    # url encoded json extra_query
    encoded_extra_query = request.query.get(&#34;extra_query&#34;) or &#34;{}&#34;
    extra_query = json.loads(encoded_extra_query)

    # defaults
    start = int(start) if isinstance(start, str) else 0
    count = int(count) if isinstance(count, str) else 10

    holder: BaseHolder = await context.inject(BaseHolder)
    try:
        credentials = await holder.get_credentials_for_presentation_request_by_referent(
            pres_ex_record.presentation_request,
            presentation_referents,
            start,
            count,
            extra_query,
        )
    except HolderError as err:
        await internal_error(err, web.HTTPBadRequest, pres_ex_record, outbound_handler)

    pres_ex_record.log_state(
        context,
        &#34;Retrieved presentation credentials&#34;,
        {
            &#34;presentation_exchange_id&#34;: presentation_exchange_id,
            &#34;referents&#34;: presentation_referents,
            &#34;extra_query&#34;: extra_query,
            &#34;credentials&#34;: credentials,
        },
    )
    return web.json_response(credentials)</code></pre>
</details>
</dd>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.routes.presentation_exchange_list"><code class="name flex">
<span>async def <span class="ident">presentation_exchange_list</span></span>(<span>request: aiohttp.web_request.BaseRequest)</span>
</code></dt>
<dd>
<div class="desc"><p>Request handler for searching presentation exchange records.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>request</code></strong></dt>
<dd>aiohttp request object</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The presentation exchange list response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@docs(tags=[&#34;present-proof&#34;], summary=&#34;Fetch all present-proof exchange records&#34;)
@querystring_schema(V10PresentationExchangeListQueryStringSchema)
@response_schema(V10PresentationExchangeListSchema(), 200)
async def presentation_exchange_list(request: web.BaseRequest):
    &#34;&#34;&#34;
    Request handler for searching presentation exchange records.

    Args:
        request: aiohttp request object

    Returns:
        The presentation exchange list response

    &#34;&#34;&#34;
    context = request.app[&#34;request_context&#34;]
    tag_filter = {}
    if &#34;thread_id&#34; in request.query and request.query[&#34;thread_id&#34;] != &#34;&#34;:
        tag_filter[&#34;thread_id&#34;] = request.query[&#34;thread_id&#34;]
    post_filter = {
        k: request.query[k]
        for k in (&#34;connection_id&#34;, &#34;role&#34;, &#34;state&#34;)
        if request.query.get(k, &#34;&#34;) != &#34;&#34;
    }

    try:
        records = await V10PresentationExchange.query(context, tag_filter, post_filter)
        results = [record.serialize() for record in records]
    except (StorageError, BaseModelError) as err:
        raise web.HTTPBadRequest(reason=err.roll_up) from err

    return web.json_response({&#34;results&#34;: results})</code></pre>
</details>
</dd>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.routes.presentation_exchange_remove"><code class="name flex">
<span>async def <span class="ident">presentation_exchange_remove</span></span>(<span>request: aiohttp.web_request.BaseRequest)</span>
</code></dt>
<dd>
<div class="desc"><p>Request handler for removing a presentation exchange record.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>request</code></strong></dt>
<dd>aiohttp request object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@docs(tags=[&#34;present-proof&#34;], summary=&#34;Remove an existing presentation exchange record&#34;)
@match_info_schema(PresExIdMatchInfoSchema())
async def presentation_exchange_remove(request: web.BaseRequest):
    &#34;&#34;&#34;
    Request handler for removing a presentation exchange record.

    Args:
        request: aiohttp request object

    &#34;&#34;&#34;
    context = request.app[&#34;request_context&#34;]
    outbound_handler = request.app[&#34;outbound_message_router&#34;]

    presentation_exchange_id = request.match_info[&#34;pres_ex_id&#34;]
    pres_ex_record = None
    try:
        pres_ex_record: V10PresentationExchange = await V10PresentationExchange.retrieve_by_id(
            context, presentation_exchange_id
        )
        await pres_ex_record.delete_record(context)

        # Initialize ADA manager
        manager = V2ADAManager(context)

        # Delete data agreement instance
        await manager.delete_da_instance_by_data_ex_id(pres_ex_record.presentation_exchange_id)

    except StorageNotFoundError as err:
        await internal_error(err, web.HTTPNotFound, pres_ex_record, outbound_handler)
    except StorageError as err:
        await internal_error(err, web.HTTPBadRequest, pres_ex_record, outbound_handler)

    return web.json_response({})</code></pre>
</details>
</dd>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.routes.presentation_exchange_retrieve"><code class="name flex">
<span>async def <span class="ident">presentation_exchange_retrieve</span></span>(<span>request: aiohttp.web_request.BaseRequest)</span>
</code></dt>
<dd>
<div class="desc"><p>Request handler for fetching a single presentation exchange record.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>request</code></strong></dt>
<dd>aiohttp request object</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The presentation exchange record response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@docs(tags=[&#34;present-proof&#34;], summary=&#34;Fetch a single presentation exchange record&#34;)
@match_info_schema(PresExIdMatchInfoSchema())
@response_schema(V10PresentationExchangeSchema(), 200)
async def presentation_exchange_retrieve(request: web.BaseRequest):
    &#34;&#34;&#34;
    Request handler for fetching a single presentation exchange record.

    Args:
        request: aiohttp request object

    Returns:
        The presentation exchange record response

    &#34;&#34;&#34;
    context = request.app[&#34;request_context&#34;]
    outbound_handler = request.app[&#34;outbound_message_router&#34;]

    presentation_exchange_id = request.match_info[&#34;pres_ex_id&#34;]
    pres_ex_record = None
    try:
        pres_ex_record = await V10PresentationExchange.retrieve_by_id(
            context, presentation_exchange_id
        )
        result = pres_ex_record.serialize()
    except StorageNotFoundError as err:
        raise web.HTTPNotFound(reason=err.roll_up) from err
    except (BaseModelError, StorageError) as err:
        await internal_error(err, web.HTTPBadRequest, pres_ex_record, outbound_handler)

    return web.json_response(result)</code></pre>
</details>
</dd>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.routes.presentation_exchange_send_bound_request"><code class="name flex">
<span>async def <span class="ident">presentation_exchange_send_bound_request</span></span>(<span>request: aiohttp.web_request.BaseRequest)</span>
</code></dt>
<dd>
<div class="desc"><p>Request handler for sending a presentation request free from any proposal.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>request</code></strong></dt>
<dd>aiohttp request object</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The presentation exchange details</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@docs(
    tags=[&#34;present-proof&#34;],
    summary=&#34;Sends a presentation request in reference to a proposal&#34;,
)
@match_info_schema(PresExIdMatchInfoSchema())
@request_schema(V10PresentationSendRequestRequestSchema())
@response_schema(V10PresentationExchangeSchema(), 200)
async def presentation_exchange_send_bound_request(request: web.BaseRequest):
    &#34;&#34;&#34;
    Request handler for sending a presentation request free from any proposal.

    Args:
        request: aiohttp request object

    Returns:
        The presentation exchange details

    &#34;&#34;&#34;
    r_time = get_timer()

    context = request.app[&#34;request_context&#34;]
    outbound_handler = request.app[&#34;outbound_message_router&#34;]

    presentation_exchange_id = request.match_info[&#34;pres_ex_id&#34;]
    pres_ex_record = await V10PresentationExchange.retrieve_by_id(
        context, presentation_exchange_id
    )
    if pres_ex_record.state != (V10PresentationExchange.STATE_PROPOSAL_RECEIVED):
        raise web.HTTPBadRequest(
            reason=(
                f&#34;Presentation exchange {presentation_exchange_id} &#34;
                f&#34;in {pres_ex_record.state} state &#34;
                f&#34;(must be {V10PresentationExchange.STATE_PROPOSAL_RECEIVED})&#34;
            )
        )
    body = await request.json()

    connection_id = body.get(&#34;connection_id&#34;)
    try:
        connection_record = await ConnectionRecord.retrieve_by_id(
            context, connection_id
        )
    except StorageError as err:
        raise web.HTTPBadRequest(reason=err.roll_up) from err

    if not connection_record.is_ready:
        raise web.HTTPForbidden(reason=f&#34;Connection {connection_id} not ready&#34;)

    presentation_manager = PresentationManager(context)
    try:
        (
            pres_ex_record,
            presentation_request_message,
        ) = await presentation_manager.create_bound_request(pres_ex_record)
        result = pres_ex_record.serialize()
    except (BaseModelError, StorageError) as err:
        await internal_error(
            err,
            web.HTTPBadRequest,
            pres_ex_record or connection_record,
            outbound_handler,
        )

    trace_msg = body.get(&#34;trace&#34;)
    presentation_request_message.assign_trace_decorator(
        context.settings,
        trace_msg,
    )
    await outbound_handler(presentation_request_message, connection_id=connection_id)

    trace_event(
        context.settings,
        presentation_request_message,
        outcome=&#34;presentation_exchange_send_request.END&#34;,
        perf_counter=r_time,
    )

    return web.json_response(result)</code></pre>
</details>
</dd>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.routes.presentation_exchange_send_free_request"><code class="name flex">
<span>async def <span class="ident">presentation_exchange_send_free_request</span></span>(<span>request: aiohttp.web_request.BaseRequest)</span>
</code></dt>
<dd>
<div class="desc"><p>Request handler for sending a presentation request free from any proposal.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>request</code></strong></dt>
<dd>aiohttp request object</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The presentation exchange details</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@docs(
    tags=[&#34;present-proof&#34;],
    summary=&#34;Sends a free presentation request not bound to any proposal&#34;,
)
@request_schema(V10PresentationSendRequestRequestSchema())
@response_schema(V10PresentationExchangeSchema(), 200)
async def presentation_exchange_send_free_request(request: web.BaseRequest):
    &#34;&#34;&#34;
    Request handler for sending a presentation request free from any proposal.

    Args:
        request: aiohttp request object

    Returns:
        The presentation exchange details

    &#34;&#34;&#34;
    r_time = get_timer()

    context = request.app[&#34;request_context&#34;]
    outbound_handler = request.app[&#34;outbound_message_router&#34;]

    body = await request.json()

    connection_id = body.get(&#34;connection_id&#34;)
    try:
        connection_record = await ConnectionRecord.retrieve_by_id(
            context, connection_id
        )
    except StorageNotFoundError as err:
        raise web.HTTPBadRequest(reason=err.roll_up) from err

    if not connection_record.is_ready:
        raise web.HTTPForbidden(reason=f&#34;Connection {connection_id} not ready&#34;)

    comment = body.get(&#34;comment&#34;)
    indy_proof_request = body.get(&#34;proof_request&#34;)
    if not indy_proof_request.get(&#34;nonce&#34;):
        indy_proof_request[&#34;nonce&#34;] = await generate_pr_nonce()

    presentation_request_message = PresentationRequest(
        comment=comment,
        request_presentations_attach=[
            AttachDecorator.from_indy_dict(
                indy_dict=indy_proof_request,
                ident=ATTACH_DECO_IDS[PRESENTATION_REQUEST],
            )
        ],
    )
    trace_msg = body.get(&#34;trace&#34;)
    presentation_request_message.assign_trace_decorator(
        context.settings,
        trace_msg,
    )

    presentation_manager = PresentationManager(context)
    pres_ex_record = None
    try:
        (pres_ex_record) = await presentation_manager.create_exchange_for_request(
            connection_id=connection_id,
            presentation_request_message=presentation_request_message,
        )
        result = pres_ex_record.serialize()
    except (BaseModelError, StorageError) as err:
        await internal_error(
            err,
            web.HTTPBadRequest,
            pres_ex_record or connection_record,
            outbound_handler,
        )

    await outbound_handler(presentation_request_message, connection_id=connection_id)

    trace_event(
        context.settings,
        presentation_request_message,
        outcome=&#34;presentation_exchange_send_request.END&#34;,
        perf_counter=r_time,
    )

    return web.json_response(result)</code></pre>
</details>
</dd>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.routes.presentation_exchange_send_presentation"><code class="name flex">
<span>async def <span class="ident">presentation_exchange_send_presentation</span></span>(<span>request: aiohttp.web_request.BaseRequest)</span>
</code></dt>
<dd>
<div class="desc"><p>Request handler for sending a presentation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>request</code></strong></dt>
<dd>aiohttp request object</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The presentation exchange details</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@docs(tags=[&#34;present-proof&#34;], summary=&#34;Sends a proof presentation&#34;)
@match_info_schema(PresExIdMatchInfoSchema())
@request_schema(V10PresentationRequestSchema())
@response_schema(V10PresentationExchangeSchema())
async def presentation_exchange_send_presentation(request: web.BaseRequest):
    &#34;&#34;&#34;
    Request handler for sending a presentation.

    Args:
        request: aiohttp request object

    Returns:
        The presentation exchange details

    &#34;&#34;&#34;
    r_time = get_timer()

    context = request.app[&#34;request_context&#34;]
    outbound_handler = request.app[&#34;outbound_message_router&#34;]
    presentation_exchange_id = request.match_info[&#34;pres_ex_id&#34;]
    pres_ex_record = await V10PresentationExchange.retrieve_by_id(
        context, presentation_exchange_id
    )
    if pres_ex_record.state != (V10PresentationExchange.STATE_REQUEST_RECEIVED):
        raise web.HTTPBadRequest(
            reason=(
                f&#34;Presentation exchange {presentation_exchange_id} &#34;
                f&#34;in {pres_ex_record.state} state &#34;
                f&#34;(must be {V10PresentationExchange.STATE_REQUEST_RECEIVED})&#34;
            )
        )

    body = await request.json()

    connection_id = pres_ex_record.connection_id
    try:
        connection_record = await ConnectionRecord.retrieve_by_id(
            context, connection_id
        )
    except StorageNotFoundError as err:
        raise web.HTTPBadRequest(reason=err.roll_up) from err

    if not connection_record.is_ready:
        raise web.HTTPForbidden(reason=f&#34;Connection {connection_id} not ready&#34;)

    presentation_manager = PresentationManager(context)
    try:
        (
            pres_ex_record,
            presentation_message,
        ) = await presentation_manager.create_presentation(
            pres_ex_record,
            {
                &#34;self_attested_attributes&#34;: body.get(&#34;self_attested_attributes&#34;),
                &#34;requested_attributes&#34;: body.get(&#34;requested_attributes&#34;),
                &#34;requested_predicates&#34;: body.get(&#34;requested_predicates&#34;),
            },
            comment=body.get(&#34;comment&#34;),
        )

        # Initialize ADA manager
        manager = V2ADAManager(context)

        # Initialize ADA manager.
        manager = V2ADAManager(context)

        # Create data agreement accept message.
        accept_message = await manager.build_data_agreement_accept_for_data_ex_record(
            connection_record,
            pres_ex_record
        )

        # Update presentation message with data agreement context decorator
        presentation_message._decorators[&#34;data-agreement-context&#34;] = \
            DataAgreementContextDecorator(
            message_type=&#34;protocol&#34;,
            message=accept_message.serialize()
        )

        result = pres_ex_record.serialize()
    except (
        BaseModelError,
        HolderError,
        LedgerError,
        StorageError,
        WalletNotFoundError,
    ) as err:
        await internal_error(
            err,
            web.HTTPBadRequest,
            pres_ex_record or connection_record,
            outbound_handler,
        )

    trace_msg = body.get(&#34;trace&#34;)
    presentation_message.assign_trace_decorator(
        context.settings,
        trace_msg,
    )
    await outbound_handler(presentation_message, connection_id=connection_id)

    trace_event(
        context.settings,
        presentation_message,
        outcome=&#34;presentation_exchange_send_request.END&#34;,
        perf_counter=r_time,
    )

    return web.json_response(result)</code></pre>
</details>
</dd>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.routes.presentation_exchange_send_proposal"><code class="name flex">
<span>async def <span class="ident">presentation_exchange_send_proposal</span></span>(<span>request: aiohttp.web_request.BaseRequest)</span>
</code></dt>
<dd>
<div class="desc"><p>Request handler for sending a presentation proposal.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>request</code></strong></dt>
<dd>aiohttp request object</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The presentation exchange details</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@docs(tags=[&#34;present-proof&#34;], summary=&#34;Sends a presentation proposal&#34;)
@request_schema(V10PresentationProposalRequestSchema())
@response_schema(V10PresentationExchangeSchema(), 200)
async def presentation_exchange_send_proposal(request: web.BaseRequest):
    &#34;&#34;&#34;
    Request handler for sending a presentation proposal.

    Args:
        request: aiohttp request object

    Returns:
        The presentation exchange details

    &#34;&#34;&#34;
    r_time = get_timer()

    context = request.app[&#34;request_context&#34;]
    outbound_handler = request.app[&#34;outbound_message_router&#34;]

    body = await request.json()

    comment = body.get(&#34;comment&#34;)
    connection_id = body.get(&#34;connection_id&#34;)

    # Aries RFC 37 calls it a proposal in the proposal struct but it&#39;s of type preview
    presentation_preview = body.get(&#34;presentation_proposal&#34;)
    connection_record = None
    try:
        connection_record = await ConnectionRecord.retrieve_by_id(
            context, connection_id
        )
        presentation_proposal_message = PresentationProposal(
            comment=comment,
            presentation_proposal=PresentationPreview.deserialize(
                presentation_preview),
        )
    except (BaseModelError, StorageError) as err:
        await internal_error(
            err, web.HTTPBadRequest, connection_record, outbound_handler
        )

    if not connection_record.is_ready:
        raise web.HTTPForbidden(reason=f&#34;Connection {connection_id} not ready&#34;)

    trace_msg = body.get(&#34;trace&#34;)
    presentation_proposal_message.assign_trace_decorator(
        context.settings,
        trace_msg,
    )
    auto_present = body.get(
        &#34;auto_present&#34;, context.settings.get(
            &#34;debug.auto_respond_presentation_request&#34;)
    )

    presentation_manager = PresentationManager(context)
    pres_ex_record = None
    try:
        pres_ex_record = await presentation_manager.create_exchange_for_proposal(
            connection_id=connection_id,
            presentation_proposal_message=presentation_proposal_message,
            auto_present=auto_present,
        )
        result = pres_ex_record.serialize()
    except (BaseModelError, StorageError) as err:
        await internal_error(
            err,
            web.HTTPBadRequest,
            pres_ex_record or connection_record,
            outbound_handler,
        )

    await outbound_handler(presentation_proposal_message, connection_id=connection_id)

    trace_event(
        context.settings,
        presentation_proposal_message,
        outcome=&#34;presentation_exchange_propose.END&#34;,
        perf_counter=r_time,
    )

    return web.json_response(result)</code></pre>
</details>
</dd>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.routes.presentation_exchange_verify_presentation"><code class="name flex">
<span>async def <span class="ident">presentation_exchange_verify_presentation</span></span>(<span>request: aiohttp.web_request.BaseRequest)</span>
</code></dt>
<dd>
<div class="desc"><p>Request handler for verifying a presentation request.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>request</code></strong></dt>
<dd>aiohttp request object</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The presentation exchange details</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@docs(tags=[&#34;present-proof&#34;], summary=&#34;Verify a received presentation&#34;)
@match_info_schema(PresExIdMatchInfoSchema())
@response_schema(V10PresentationExchangeSchema())
async def presentation_exchange_verify_presentation(request: web.BaseRequest):
    &#34;&#34;&#34;
    Request handler for verifying a presentation request.

    Args:
        request: aiohttp request object

    Returns:
        The presentation exchange details

    &#34;&#34;&#34;
    r_time = get_timer()

    context = request.app[&#34;request_context&#34;]
    outbound_handler = request.app[&#34;outbound_message_router&#34;]

    presentation_exchange_id = request.match_info[&#34;pres_ex_id&#34;]

    pres_ex_record = await V10PresentationExchange.retrieve_by_id(
        context, presentation_exchange_id
    )
    if pres_ex_record.state != (V10PresentationExchange.STATE_PRESENTATION_RECEIVED):
        raise web.HTTPBadRequest(
            reason=(
                f&#34;Presentation exchange {presentation_exchange_id} &#34;
                f&#34;in {pres_ex_record.state} state &#34;
                f&#34;(must be {V10PresentationExchange.STATE_PRESENTATION_RECEIVED})&#34;
            )
        )

    connection_id = pres_ex_record.connection_id

    try:
        connection_record = await ConnectionRecord.retrieve_by_id(
            context, connection_id
        )
    except StorageError as err:
        raise web.HTTPBadRequest(reason=err.roll_up) from err

    if not connection_record.is_ready:
        raise web.HTTPForbidden(reason=f&#34;Connection {connection_id} not ready&#34;)

    presentation_manager = PresentationManager(context)
    try:
        pres_ex_record = await presentation_manager.verify_presentation(pres_ex_record)
        result = pres_ex_record.serialize()
    except (LedgerError, BaseModelError) as err:
        await internal_error(err, web.HTTPBadRequest, pres_ex_record, outbound_handler)

    trace_event(
        context.settings,
        pres_ex_record,
        outcome=&#34;presentation_exchange_verify.END&#34;,
        perf_counter=r_time,
    )

    return web.json_response(result)</code></pre>
</details>
</dd>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.routes.register"><code class="name flex">
<span>async def <span class="ident">register</span></span>(<span>app: aiohttp.web_app.Application)</span>
</code></dt>
<dd>
<div class="desc"><p>Register routes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def register(app: web.Application):
    &#34;&#34;&#34;Register routes.&#34;&#34;&#34;

    app.add_routes(
        [
            web.get(
                &#34;/present-proof/records&#34;, presentation_exchange_list, allow_head=False
            ),
            web.get(
                &#34;/present-proof/records/{pres_ex_id}&#34;,
                presentation_exchange_retrieve,
                allow_head=False,
            ),
            web.get(
                &#34;/present-proof/records/{pres_ex_id}/credentials&#34;,
                presentation_exchange_credentials_list,
                allow_head=False,
            ),
            web.post(
                &#34;/present-proof/send-proposal&#34;,
                presentation_exchange_send_proposal,
            ),
            web.post(
                &#34;/present-proof/create-request&#34;,
                presentation_exchange_create_request,
            ),
            web.post(
                &#34;/present-proof/send-request&#34;,
                presentation_exchange_send_free_request,
            ),
            web.post(
                &#34;/present-proof/records/{pres_ex_id}/send-request&#34;,
                presentation_exchange_send_bound_request,
            ),
            web.post(
                &#34;/present-proof/records/{pres_ex_id}/send-presentation&#34;,
                presentation_exchange_send_presentation,
            ),
            web.post(
                &#34;/present-proof/records/{pres_ex_id}/verify-presentation&#34;,
                presentation_exchange_verify_presentation,
            ),
            web.delete(
                &#34;/present-proof/records/{pres_ex_id}&#34;,
                presentation_exchange_remove,
            ),
            web.post(
                &#34;/present-proof/data-agreement-negotiation/offer&#34;,
                send_presentation_request_for_data_agreement,
            )
        ]
    )</code></pre>
</details>
</dd>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.routes.send_presentation_request_for_data_agreement"><code class="name flex">
<span>async def <span class="ident">send_presentation_request_for_data_agreement</span></span>(<span>request: aiohttp.web_request.BaseRequest)</span>
</code></dt>
<dd>
<div class="desc"><p>Sent a presentation request in reference to a data agreement.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>request</code></strong></dt>
<dd>aiohttp request object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@docs(tags=[&#34;present-proof&#34;],
      summary=&#34;Send a presentation request in reference to a data agreement&#34;)
@request_schema(SendPresentationRequestForDataAgreementRequestSchema())
async def send_presentation_request_for_data_agreement(request: web.BaseRequest):
    &#34;&#34;&#34;
    Sent a presentation request in reference to a data agreement.

    Args:
        request: aiohttp request object
    &#34;&#34;&#34;

    # Retrieve context
    context = request.app[&#34;request_context&#34;]

    # Outbound message handler
    outbound_handler = request.app[&#34;outbound_message_router&#34;]

    # Request payload
    body = await request.json()

    # Data agreement template identifier
    template_id = body.get(&#34;template_id&#34;)

    # Connection identifier
    connection_id = body.get(&#34;connection_id&#34;)

    # Fetch the connection record
    connection_record: ConnectionRecord = await ConnectionRecord.retrieve_by_id(
        context,
        connection_id
    )

    if not connection_record.is_ready:
        raise web.HTTPForbidden(reason=f&#34;Connection {connection_id} not ready&#34;)

    # Initialise ADA manager
    manager = V2ADAManager(context)

    # Fetch data agreement template
    template: DataAgreementTemplateRecord = \
        await DataAgreementTemplateRecord.latest_published_template_by_id(
            context, template_id
        )

    if not template:
        raise web.HTTPException(reason=&#34;Data agreement template not found.&#34;)

    if template.method_of_use != DataAgreementTemplateRecord.METHOD_OF_USE_DATA_USING_SERVICE:
        raise web.HTTPException(reason=&#34;Data agreement method of use must be data-using-service.&#34;)

    # Construct presentation request
    preset_presentation_request = template.presentation_request
    comment = preset_presentation_request.pop(&#34;comment&#34;)
    if not preset_presentation_request.get(&#34;nonce&#34;):
        preset_presentation_request[&#34;nonce&#34;] = await generate_pr_nonce()

    presentation_request = PresentationRequest(
        comment=comment,
        request_presentations_attach=[
            AttachDecorator.from_indy_dict(
                indy_dict=preset_presentation_request,
                ident=ATTACH_DECO_IDS[PRESENTATION_REQUEST],
            )
        ],
    )

    # Construct presentation exchange record
    presentation_manager = PresentationManager(context)
    pres_ex_record = None
    try:
        (pres_ex_record) = await presentation_manager.create_exchange_for_request(
            connection_id=connection_id,
            presentation_request_message=presentation_request,
        )
        result = pres_ex_record.serialize()
    except (BaseModelError, StorageError) as err:
        await internal_error(
            err,
            web.HTTPBadRequest,
            pres_ex_record or connection_record,
            outbound_handler,
        )

    # Build data agreement offer message
    da_offer_message = await manager.build_data_agreement_offer_for_presentation_exchange(
        template_id,
        connection_record,
        pres_ex_record
    )

    # Add data agreement context decorator
    presentation_request._decorators[&#34;data-agreement-context&#34;] = \
        DataAgreementContextDecorator(
        message_type=&#34;protocol&#34;,
        message=da_offer_message.serialize()
    )

    pres_ex_record.presentation_request_dict = presentation_request.serialize()
    await pres_ex_record.save(context)

    result = pres_ex_record.serialize()

    await outbound_handler(presentation_request, connection_id=connection_id)

    return web.json_response(result)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.routes.CredentialsFetchQueryStringSchema"><code class="flex name class">
<span>class <span class="ident">CredentialsFetchQueryStringSchema</span></span>
<span>(</span><span>*, only: Union[Sequence[str], Set[str]] = None, exclude: Union[Sequence[str], Set[str]] = (), many: bool = False, context: Dict[~KT, ~VT] = None, load_only: Union[Sequence[str], Set[str]] = (), dump_only: Union[Sequence[str], Set[str]] = (), partial: Union[bool, Sequence[str], Set[str]] = False, unknown: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Parameters and validators for credentials fetch request query string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CredentialsFetchQueryStringSchema(OpenAPISchema):
    &#34;&#34;&#34;Parameters and validators for credentials fetch request query string.&#34;&#34;&#34;

    referent = fields.Str(
        description=&#34;Proof request referents of interest, comma-separated&#34;,
        required=False,
        example=&#34;1_name_uuid,2_score_uuid&#34;,
    )
    start = fields.Int(description=&#34;Start index&#34;, required=False, **WHOLE_NUM)
    count = fields.Int(
        description=&#34;Maximum number to retrieve&#34;, required=False, **NATURAL_NUM
    )
    extra_query = fields.Str(
        description=&#34;(JSON) object mapping referents to extra WQL queries&#34;,
        required=False,
        **INDY_EXTRA_WQL,
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>aries_cloudagent.messaging.models.openapi.OpenAPISchema</li>
<li>marshmallow.schema.Schema</li>
<li>marshmallow.base.SchemaABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.routes.CredentialsFetchQueryStringSchema.opts"><code class="name">var <span class="ident">opts</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.routes.DAIndyProofReqAttrSpecSchema"><code class="flex name class">
<span>class <span class="ident">DAIndyProofReqAttrSpecSchema</span></span>
<span>(</span><span>*, only: Union[Sequence[str], Set[str]] = None, exclude: Union[Sequence[str], Set[str]] = (), many: bool = False, context: Dict[~KT, ~VT] = None, load_only: Union[Sequence[str], Set[str]] = (), dump_only: Union[Sequence[str], Set[str]] = (), partial: Union[bool, Sequence[str], Set[str]] = False, unknown: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Schema for attribute specification in indy proof request.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DAIndyProofReqAttrSpecSchema(OpenAPISchema):
    &#34;&#34;&#34;Schema for attribute specification in indy proof request.&#34;&#34;&#34;

    name = fields.String(
        example=&#34;favouriteDrink&#34;, description=&#34;Attribute name&#34;, required=False
    )
    names = fields.List(
        fields.String(example=&#34;age&#34;),
        description=&#34;Attribute name group&#34;,
        required=False,
    )
    restrictions = fields.List(
        fields.Dict(
            keys=fields.Str(
                validate=validate.Regexp(
                    &#34;^schema_id|&#34;
                    &#34;schema_issuer_did|&#34;
                    &#34;schema_name|&#34;
                    &#34;schema_version|&#34;
                    &#34;issuer_did|&#34;
                    &#34;cred_def_id|&#34;
                    &#34;attr::.+::value$&#34;  # indy does not support attr::...::marker here
                ),
                example=&#34;cred_def_id&#34;,  # marshmallow/apispec v3.0 ignores
            ),
            values=fields.Str(example=INDY_CRED_DEF_ID[&#34;example&#34;]),
        ),
        description=(
            &#34;If present, credential must satisfy one of given restrictions: specify &#34;
            &#34;schema_id, schema_issuer_did, schema_name, schema_version, &#34;
            &#34;issuer_did, cred_def_id, and/or attr::&lt;attribute-name&gt;::value &#34;
            &#34;where &lt;attribute-name&gt; represents a credential attribute name&#34;
        ),
        required=False,
    )
    non_revoked = fields.Nested(
        DAIndyProofReqNonRevokedSchema(), required=False)

    @validates_schema
    def validate_fields(self, data, **kwargs):
        &#34;&#34;&#34;
        Validate schema fields.

        Data must have exactly one of name or names; if names then restrictions are
        mandatory.

        Args:
            data: The data to validate

        Raises:
            ValidationError: if data has both or neither of name and names

        &#34;&#34;&#34;
        if (&#34;name&#34; in data) == (&#34;names&#34; in data):
            raise ValidationError(
                &#34;Attribute specification must have either name or names but not both&#34;
            )
        restrictions = data.get(&#34;restrictions&#34;)
        if (&#34;names&#34; in data) and (not restrictions or all(not r for r in restrictions)):
            raise ValidationError(
                &#34;Attribute specification on &#39;names&#39; must have non-empty restrictions&#34;
            )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>aries_cloudagent.messaging.models.openapi.OpenAPISchema</li>
<li>marshmallow.schema.Schema</li>
<li>marshmallow.base.SchemaABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.routes.DAIndyProofReqAttrSpecSchema.opts"><code class="name">var <span class="ident">opts</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.routes.DAIndyProofReqAttrSpecSchema.validate_fields"><code class="name flex">
<span>def <span class="ident">validate_fields</span></span>(<span>self, data, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Validate schema fields.</p>
<p>Data must have exactly one of name or names; if names then restrictions are
mandatory.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>The data to validate</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValidationError</code></dt>
<dd>if data has both or neither of name and names</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validates_schema
def validate_fields(self, data, **kwargs):
    &#34;&#34;&#34;
    Validate schema fields.

    Data must have exactly one of name or names; if names then restrictions are
    mandatory.

    Args:
        data: The data to validate

    Raises:
        ValidationError: if data has both or neither of name and names

    &#34;&#34;&#34;
    if (&#34;name&#34; in data) == (&#34;names&#34; in data):
        raise ValidationError(
            &#34;Attribute specification must have either name or names but not both&#34;
        )
    restrictions = data.get(&#34;restrictions&#34;)
    if (&#34;names&#34; in data) and (not restrictions or all(not r for r in restrictions)):
        raise ValidationError(
            &#34;Attribute specification on &#39;names&#39; must have non-empty restrictions&#34;
        )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.routes.DAIndyProofReqNonRevokedSchema"><code class="flex name class">
<span>class <span class="ident">DAIndyProofReqNonRevokedSchema</span></span>
<span>(</span><span>*, only: Union[Sequence[str], Set[str]] = None, exclude: Union[Sequence[str], Set[str]] = (), many: bool = False, context: Dict[~KT, ~VT] = None, load_only: Union[Sequence[str], Set[str]] = (), dump_only: Union[Sequence[str], Set[str]] = (), partial: Union[bool, Sequence[str], Set[str]] = False, unknown: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Non-revocation times specification in indy proof request.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DAIndyProofReqNonRevokedSchema(OpenAPISchema):
    &#34;&#34;&#34;Non-revocation times specification in indy proof request.&#34;&#34;&#34;

    fro = fields.Int(
        description=&#34;Earliest epoch of interest for non-revocation proof&#34;,
        required=False,
        data_key=&#34;from&#34;,
        **INT_EPOCH,
    )
    to = fields.Int(
        description=&#34;Latest epoch of interest for non-revocation proof&#34;,
        required=False,
        **INT_EPOCH,
    )

    @validates_schema
    def validate_fields(self, data, **kwargs):
        &#34;&#34;&#34;
        Validate schema fields - must have from, to, or both.

        Args:
            data: The data to validate

        Raises:
            ValidationError: if data has neither from nor to

        &#34;&#34;&#34;
        if not (data.get(&#34;from&#34;) or data.get(&#34;to&#34;)):
            raise ValidationError(
                &#34;Non-revocation interval must have at least one end&#34;, (&#34;fro&#34;,
                                                                       &#34;to&#34;)
            )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>aries_cloudagent.messaging.models.openapi.OpenAPISchema</li>
<li>marshmallow.schema.Schema</li>
<li>marshmallow.base.SchemaABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.routes.DAIndyProofReqNonRevokedSchema.opts"><code class="name">var <span class="ident">opts</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.routes.DAIndyProofReqNonRevokedSchema.validate_fields"><code class="name flex">
<span>def <span class="ident">validate_fields</span></span>(<span>self, data, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Validate schema fields - must have from, to, or both.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>The data to validate</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValidationError</code></dt>
<dd>if data has neither from nor to</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validates_schema
def validate_fields(self, data, **kwargs):
    &#34;&#34;&#34;
    Validate schema fields - must have from, to, or both.

    Args:
        data: The data to validate

    Raises:
        ValidationError: if data has neither from nor to

    &#34;&#34;&#34;
    if not (data.get(&#34;from&#34;) or data.get(&#34;to&#34;)):
        raise ValidationError(
            &#34;Non-revocation interval must have at least one end&#34;, (&#34;fro&#34;,
                                                                   &#34;to&#34;)
        )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.routes.DAIndyProofReqPredSpecRestrictionsSchema"><code class="flex name class">
<span>class <span class="ident">DAIndyProofReqPredSpecRestrictionsSchema</span></span>
<span>(</span><span>*, only: Union[Sequence[str], Set[str]] = None, exclude: Union[Sequence[str], Set[str]] = (), many: bool = False, context: Dict[~KT, ~VT] = None, load_only: Union[Sequence[str], Set[str]] = (), dump_only: Union[Sequence[str], Set[str]] = (), partial: Union[bool, Sequence[str], Set[str]] = False, unknown: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Schema for restrictions in attr or pred specifier indy proof request.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DAIndyProofReqPredSpecRestrictionsSchema(OpenAPISchema):
    &#34;&#34;&#34;Schema for restrictions in attr or pred specifier indy proof request.&#34;&#34;&#34;

    schema_id = fields.String(
        description=&#34;Schema identifier&#34;, required=False, **INDY_SCHEMA_ID
    )
    schema_issuer_did = fields.String(
        description=&#34;Schema issuer (origin) DID&#34;, required=False, **INDY_DID
    )
    schema_name = fields.String(
        example=&#34;transcript&#34;, description=&#34;Schema name&#34;, required=False
    )
    schema_version = fields.String(
        description=&#34;Schema version&#34;, required=False, **INDY_VERSION
    )
    issuer_did = fields.String(
        description=&#34;Credential issuer DID&#34;, required=False, **INDY_DID
    )
    cred_def_id = fields.String(
        description=&#34;Credential definition identifier&#34;,
        required=False,
        **INDY_CRED_DEF_ID,
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>aries_cloudagent.messaging.models.openapi.OpenAPISchema</li>
<li>marshmallow.schema.Schema</li>
<li>marshmallow.base.SchemaABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.routes.DAIndyProofReqPredSpecRestrictionsSchema.opts"><code class="name">var <span class="ident">opts</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.routes.DAIndyProofReqPredSpecSchema"><code class="flex name class">
<span>class <span class="ident">DAIndyProofReqPredSpecSchema</span></span>
<span>(</span><span>*, only: Union[Sequence[str], Set[str]] = None, exclude: Union[Sequence[str], Set[str]] = (), many: bool = False, context: Dict[~KT, ~VT] = None, load_only: Union[Sequence[str], Set[str]] = (), dump_only: Union[Sequence[str], Set[str]] = (), partial: Union[bool, Sequence[str], Set[str]] = False, unknown: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Schema for predicate specification in indy proof request.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DAIndyProofReqPredSpecSchema(OpenAPISchema):
    &#34;&#34;&#34;Schema for predicate specification in indy proof request.&#34;&#34;&#34;

    name = fields.String(
        example=&#34;index&#34;, description=&#34;Attribute name&#34;, required=True)
    p_type = fields.String(
        description=&#34;Predicate type (&#39;&lt;&#39;, &#39;&lt;=&#39;, &#39;&gt;=&#39;, or &#39;&gt;&#39;)&#34;,
        required=True,
        **INDY_PREDICATE,
    )
    p_value = fields.Integer(description=&#34;Threshold value&#34;, required=True)
    restrictions = fields.List(
        fields.Nested(DAIndyProofReqPredSpecRestrictionsSchema()),
        description=&#34;If present, credential must satisfy one of given restrictions&#34;,
        required=False,
    )
    non_revoked = fields.Nested(
        DAIndyProofReqNonRevokedSchema(), required=False)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>aries_cloudagent.messaging.models.openapi.OpenAPISchema</li>
<li>marshmallow.schema.Schema</li>
<li>marshmallow.base.SchemaABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.routes.DAIndyProofReqPredSpecSchema.opts"><code class="name">var <span class="ident">opts</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.routes.DAIndyProofRequestSchema"><code class="flex name class">
<span>class <span class="ident">DAIndyProofRequestSchema</span></span>
<span>(</span><span>*, only: Union[Sequence[str], Set[str]] = None, exclude: Union[Sequence[str], Set[str]] = (), many: bool = False, context: Dict[~KT, ~VT] = None, load_only: Union[Sequence[str], Set[str]] = (), dump_only: Union[Sequence[str], Set[str]] = (), partial: Union[bool, Sequence[str], Set[str]] = False, unknown: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Schema for indy proof request.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DAIndyProofRequestSchema(OpenAPISchema):
    &#34;&#34;&#34;Schema for indy proof request.&#34;&#34;&#34;

    nonce = fields.String(description=&#34;Nonce&#34;,
                          required=False, example=&#34;1234567890&#34;)
    name = fields.String(
        description=&#34;Proof request name&#34;,
        required=False,
        example=&#34;Proof request&#34;,
        default=&#34;Proof request&#34;,
    )
    version = fields.String(
        description=&#34;Proof request version&#34;,
        required=False,
        default=&#34;1.0&#34;,
        **INDY_VERSION,
    )
    requested_attributes = fields.Dict(
        description=(&#34;Requested attribute specifications of proof request&#34;),
        required=True,
        # marshmallow/apispec v3.0 ignores
        keys=fields.Str(example=&#34;0_attr_uuid&#34;),
        values=fields.Nested(DAIndyProofReqAttrSpecSchema()),
    )
    requested_predicates = fields.Dict(
        description=(&#34;Requested predicate specifications of proof request&#34;),
        required=True,
        # marshmallow/apispec v3.0 ignores
        keys=fields.Str(example=&#34;0_age_GE_uuid&#34;),
        values=fields.Nested(DAIndyProofReqPredSpecSchema()),
    )
    non_revoked = fields.Nested(
        DAIndyProofReqNonRevokedSchema(), required=False)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>aries_cloudagent.messaging.models.openapi.OpenAPISchema</li>
<li>marshmallow.schema.Schema</li>
<li>marshmallow.base.SchemaABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.routes.DAIndyProofRequestSchema.opts"><code class="name">var <span class="ident">opts</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.routes.IndyRequestedCredsRequestedAttrSchema"><code class="flex name class">
<span>class <span class="ident">IndyRequestedCredsRequestedAttrSchema</span></span>
<span>(</span><span>*, only: Union[Sequence[str], Set[str]] = None, exclude: Union[Sequence[str], Set[str]] = (), many: bool = False, context: Dict[~KT, ~VT] = None, load_only: Union[Sequence[str], Set[str]] = (), dump_only: Union[Sequence[str], Set[str]] = (), partial: Union[bool, Sequence[str], Set[str]] = False, unknown: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Schema for requested attributes within indy requested credentials structure.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IndyRequestedCredsRequestedAttrSchema(OpenAPISchema):
    &#34;&#34;&#34;Schema for requested attributes within indy requested credentials structure.&#34;&#34;&#34;

    cred_id = fields.Str(
        example=&#34;3fa85f64-5717-4562-b3fc-2c963f66afa6&#34;,
        description=(
            &#34;Wallet credential identifier (typically but not necessarily a UUID)&#34;
        ),
        required=True,
    )
    revealed = fields.Bool(
        description=&#34;Whether to reveal attribute in proof&#34;, required=True
    )
    timestamp = fields.Int(
        description=&#34;Epoch timestamp of interest for non-revocation proof&#34;,
        required=False,
        **INT_EPOCH,
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>aries_cloudagent.messaging.models.openapi.OpenAPISchema</li>
<li>marshmallow.schema.Schema</li>
<li>marshmallow.base.SchemaABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.routes.IndyRequestedCredsRequestedAttrSchema.opts"><code class="name">var <span class="ident">opts</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.routes.IndyRequestedCredsRequestedPredSchema"><code class="flex name class">
<span>class <span class="ident">IndyRequestedCredsRequestedPredSchema</span></span>
<span>(</span><span>*, only: Union[Sequence[str], Set[str]] = None, exclude: Union[Sequence[str], Set[str]] = (), many: bool = False, context: Dict[~KT, ~VT] = None, load_only: Union[Sequence[str], Set[str]] = (), dump_only: Union[Sequence[str], Set[str]] = (), partial: Union[bool, Sequence[str], Set[str]] = False, unknown: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Schema for requested predicates within indy requested credentials structure.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IndyRequestedCredsRequestedPredSchema(OpenAPISchema):
    &#34;&#34;&#34;Schema for requested predicates within indy requested credentials structure.&#34;&#34;&#34;

    cred_id = fields.Str(
        description=(
            &#34;Wallet credential identifier (typically but not necessarily a UUID)&#34;
        ),
        example=&#34;3fa85f64-5717-4562-b3fc-2c963f66afa6&#34;,
        required=True,
    )
    timestamp = fields.Int(
        description=&#34;Epoch timestamp of interest for non-revocation proof&#34;,
        required=False,
        **INT_EPOCH,
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>aries_cloudagent.messaging.models.openapi.OpenAPISchema</li>
<li>marshmallow.schema.Schema</li>
<li>marshmallow.base.SchemaABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.routes.IndyRequestedCredsRequestedPredSchema.opts"><code class="name">var <span class="ident">opts</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.routes.PresExIdMatchInfoSchema"><code class="flex name class">
<span>class <span class="ident">PresExIdMatchInfoSchema</span></span>
<span>(</span><span>*, only: Union[Sequence[str], Set[str]] = None, exclude: Union[Sequence[str], Set[str]] = (), many: bool = False, context: Dict[~KT, ~VT] = None, load_only: Union[Sequence[str], Set[str]] = (), dump_only: Union[Sequence[str], Set[str]] = (), partial: Union[bool, Sequence[str], Set[str]] = False, unknown: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Path parameters and validators for request taking presentation exchange id.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PresExIdMatchInfoSchema(OpenAPISchema):
    &#34;&#34;&#34;Path parameters and validators for request taking presentation exchange id.&#34;&#34;&#34;

    pres_ex_id = fields.Str(
        description=&#34;Presentation exchange identifier&#34;, required=True, **UUID4
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>aries_cloudagent.messaging.models.openapi.OpenAPISchema</li>
<li>marshmallow.schema.Schema</li>
<li>marshmallow.base.SchemaABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.routes.PresExIdMatchInfoSchema.opts"><code class="name">var <span class="ident">opts</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.routes.SendPresentationRequestForDataAgreementRequestSchema"><code class="flex name class">
<span>class <span class="ident">SendPresentationRequestForDataAgreementRequestSchema</span></span>
<span>(</span><span>*, only: Union[Sequence[str], Set[str]] = None, exclude: Union[Sequence[str], Set[str]] = (), many: bool = False, context: Dict[~KT, ~VT] = None, load_only: Union[Sequence[str], Set[str]] = (), dump_only: Union[Sequence[str], Set[str]] = (), partial: Union[bool, Sequence[str], Set[str]] = False, unknown: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Request schema for sending a presentation request for a data agreement.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SendPresentationRequestForDataAgreementRequestSchema(OpenAPISchema):
    &#34;&#34;&#34;Request schema for sending a presentation request for a data agreement.&#34;&#34;&#34;

    # Connection identifier
    connection_id = fields.UUID(required=True)

    # Data agreement template identifier
    template_id = fields.Str(required=True)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>aries_cloudagent.messaging.models.openapi.OpenAPISchema</li>
<li>marshmallow.schema.Schema</li>
<li>marshmallow.base.SchemaABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.routes.SendPresentationRequestForDataAgreementRequestSchema.opts"><code class="name">var <span class="ident">opts</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.routes.V10PresentationCreateRequestRequestSchema"><code class="flex name class">
<span>class <span class="ident">V10PresentationCreateRequestRequestSchema</span></span>
<span>(</span><span>*, only: Union[Sequence[str], Set[str]] = None, exclude: Union[Sequence[str], Set[str]] = (), many: bool = False, context: Dict[~KT, ~VT] = None, load_only: Union[Sequence[str], Set[str]] = (), dump_only: Union[Sequence[str], Set[str]] = (), partial: Union[bool, Sequence[str], Set[str]] = False, unknown: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Request schema for creating a proof request free of any connection.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class V10PresentationCreateRequestRequestSchema(AdminAPIMessageTracingSchema):
    &#34;&#34;&#34;Request schema for creating a proof request free of any connection.&#34;&#34;&#34;

    proof_request = fields.Nested(DAIndyProofRequestSchema(), required=True)
    comment = fields.Str(required=False, allow_none=True)
    trace = fields.Bool(
        description=&#34;Whether to trace event (default false)&#34;,
        required=False,
        example=False,
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>aries_cloudagent.utils.tracing.AdminAPIMessageTracingSchema</li>
<li>aries_cloudagent.messaging.models.openapi.OpenAPISchema</li>
<li>marshmallow.schema.Schema</li>
<li>marshmallow.base.SchemaABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mydata_did.patched_protocols.present_proof.v1_0.routes.V10PresentationSendRequestRequestSchema" href="#mydata_did.patched_protocols.present_proof.v1_0.routes.V10PresentationSendRequestRequestSchema">V10PresentationSendRequestRequestSchema</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.routes.V10PresentationCreateRequestRequestSchema.opts"><code class="name">var <span class="ident">opts</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.routes.V10PresentationExchangeListQueryStringSchema"><code class="flex name class">
<span>class <span class="ident">V10PresentationExchangeListQueryStringSchema</span></span>
<span>(</span><span>*, only: Union[Sequence[str], Set[str]] = None, exclude: Union[Sequence[str], Set[str]] = (), many: bool = False, context: Dict[~KT, ~VT] = None, load_only: Union[Sequence[str], Set[str]] = (), dump_only: Union[Sequence[str], Set[str]] = (), partial: Union[bool, Sequence[str], Set[str]] = False, unknown: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Parameters and validators for presentation exchange list query.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class V10PresentationExchangeListQueryStringSchema(OpenAPISchema):
    &#34;&#34;&#34;Parameters and validators for presentation exchange list query.&#34;&#34;&#34;

    connection_id = fields.UUID(
        description=&#34;Connection identifier&#34;,
        required=False,
        example=UUIDFour.EXAMPLE,  # typically but not necessarily a UUID4
    )
    thread_id = fields.UUID(
        description=&#34;Thread identifier&#34;,
        required=False,
        example=UUIDFour.EXAMPLE,  # typically but not necessarily a UUID4
    )
    role = fields.Str(
        description=&#34;Role assigned in presentation exchange&#34;,
        required=False,
        validate=validate.OneOf(
            [
                getattr(V10PresentationExchange, m)
                for m in vars(V10PresentationExchange)
                if m.startswith(&#34;ROLE_&#34;)
            ]
        ),
    )
    state = fields.Str(
        description=&#34;Presentation exchange state&#34;,
        required=False,
        validate=validate.OneOf(
            [
                getattr(V10PresentationExchange, m)
                for m in vars(V10PresentationExchange)
                if m.startswith(&#34;STATE_&#34;)
            ]
        ),
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>aries_cloudagent.messaging.models.openapi.OpenAPISchema</li>
<li>marshmallow.schema.Schema</li>
<li>marshmallow.base.SchemaABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.routes.V10PresentationExchangeListQueryStringSchema.opts"><code class="name">var <span class="ident">opts</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.routes.V10PresentationExchangeListSchema"><code class="flex name class">
<span>class <span class="ident">V10PresentationExchangeListSchema</span></span>
<span>(</span><span>*, only: Union[Sequence[str], Set[str]] = None, exclude: Union[Sequence[str], Set[str]] = (), many: bool = False, context: Dict[~KT, ~VT] = None, load_only: Union[Sequence[str], Set[str]] = (), dump_only: Union[Sequence[str], Set[str]] = (), partial: Union[bool, Sequence[str], Set[str]] = False, unknown: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Result schema for an Aries RFC 37 v1.0 presentation exchange query.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class V10PresentationExchangeListSchema(OpenAPISchema):
    &#34;&#34;&#34;Result schema for an Aries RFC 37 v1.0 presentation exchange query.&#34;&#34;&#34;

    results = fields.List(
        fields.Nested(V10PresentationExchangeSchema()),
        description=&#34;Aries RFC 37 v1.0 presentation exchange records&#34;,
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>aries_cloudagent.messaging.models.openapi.OpenAPISchema</li>
<li>marshmallow.schema.Schema</li>
<li>marshmallow.base.SchemaABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.routes.V10PresentationExchangeListSchema.opts"><code class="name">var <span class="ident">opts</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.routes.V10PresentationProposalRequestSchema"><code class="flex name class">
<span>class <span class="ident">V10PresentationProposalRequestSchema</span></span>
<span>(</span><span>*, only: Union[Sequence[str], Set[str]] = None, exclude: Union[Sequence[str], Set[str]] = (), many: bool = False, context: Dict[~KT, ~VT] = None, load_only: Union[Sequence[str], Set[str]] = (), dump_only: Union[Sequence[str], Set[str]] = (), partial: Union[bool, Sequence[str], Set[str]] = False, unknown: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Request schema for sending a presentation proposal admin message.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class V10PresentationProposalRequestSchema(AdminAPIMessageTracingSchema):
    &#34;&#34;&#34;Request schema for sending a presentation proposal admin message.&#34;&#34;&#34;

    connection_id = fields.UUID(
        description=&#34;Connection identifier&#34;, required=True, example=UUIDFour.EXAMPLE
    )
    comment = fields.Str(
        description=&#34;Human-readable comment&#34;, required=False, allow_none=True
    )
    presentation_proposal = fields.Nested(
        PresentationPreviewSchema(), required=True)
    auto_present = fields.Boolean(
        description=(
            &#34;Whether to respond automatically to presentation requests, building &#34;
            &#34;and presenting requested proof&#34;
        ),
        required=False,
        default=False,
    )
    trace = fields.Bool(
        description=&#34;Whether to trace event (default false)&#34;,
        required=False,
        example=False,
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>aries_cloudagent.utils.tracing.AdminAPIMessageTracingSchema</li>
<li>aries_cloudagent.messaging.models.openapi.OpenAPISchema</li>
<li>marshmallow.schema.Schema</li>
<li>marshmallow.base.SchemaABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.routes.V10PresentationProposalRequestSchema.opts"><code class="name">var <span class="ident">opts</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.routes.V10PresentationRequestSchema"><code class="flex name class">
<span>class <span class="ident">V10PresentationRequestSchema</span></span>
<span>(</span><span>*, only: Union[Sequence[str], Set[str]] = None, exclude: Union[Sequence[str], Set[str]] = (), many: bool = False, context: Dict[~KT, ~VT] = None, load_only: Union[Sequence[str], Set[str]] = (), dump_only: Union[Sequence[str], Set[str]] = (), partial: Union[bool, Sequence[str], Set[str]] = False, unknown: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Request schema for sending a presentation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class V10PresentationRequestSchema(AdminAPIMessageTracingSchema):
    &#34;&#34;&#34;Request schema for sending a presentation.&#34;&#34;&#34;

    self_attested_attributes = fields.Dict(
        description=(&#34;Self-attested attributes to build into proof&#34;),
        required=True,
        # marshmallow/apispec v3.0 ignores
        keys=fields.Str(example=&#34;attr_name&#34;),
        values=fields.Str(
            example=&#34;self_attested_value&#34;,
            description=(
                &#34;Self-attested attribute values to use in requested-credentials &#34;
                &#34;structure for proof construction&#34;
            ),
        ),
    )
    requested_attributes = fields.Dict(
        description=(
            &#34;Nested object mapping proof request attribute referents to &#34;
            &#34;requested-attribute specifiers&#34;
        ),
        required=True,
        # marshmallow/apispec v3.0 ignores
        keys=fields.Str(example=&#34;attr_referent&#34;),
        values=fields.Nested(IndyRequestedCredsRequestedAttrSchema()),
    )
    requested_predicates = fields.Dict(
        description=(
            &#34;Nested object mapping proof request predicate referents to &#34;
            &#34;requested-predicate specifiers&#34;
        ),
        required=True,
        # marshmallow/apispec v3.0 ignores
        keys=fields.Str(example=&#34;pred_referent&#34;),
        values=fields.Nested(IndyRequestedCredsRequestedPredSchema()),
    )
    trace = fields.Bool(
        description=&#34;Whether to trace event (default false)&#34;,
        required=False,
        example=False,
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>aries_cloudagent.utils.tracing.AdminAPIMessageTracingSchema</li>
<li>aries_cloudagent.messaging.models.openapi.OpenAPISchema</li>
<li>marshmallow.schema.Schema</li>
<li>marshmallow.base.SchemaABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.routes.V10PresentationRequestSchema.opts"><code class="name">var <span class="ident">opts</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.routes.V10PresentationSendRequestRequestSchema"><code class="flex name class">
<span>class <span class="ident">V10PresentationSendRequestRequestSchema</span></span>
<span>(</span><span>*, only: Union[Sequence[str], Set[str]] = None, exclude: Union[Sequence[str], Set[str]] = (), many: bool = False, context: Dict[~KT, ~VT] = None, load_only: Union[Sequence[str], Set[str]] = (), dump_only: Union[Sequence[str], Set[str]] = (), partial: Union[bool, Sequence[str], Set[str]] = False, unknown: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Request schema for sending a proof request on a connection.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class V10PresentationSendRequestRequestSchema(
    V10PresentationCreateRequestRequestSchema
):
    &#34;&#34;&#34;Request schema for sending a proof request on a connection.&#34;&#34;&#34;

    connection_id = fields.UUID(
        description=&#34;Connection identifier&#34;, required=True, example=UUIDFour.EXAMPLE
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mydata_did.patched_protocols.present_proof.v1_0.routes.V10PresentationCreateRequestRequestSchema" href="#mydata_did.patched_protocols.present_proof.v1_0.routes.V10PresentationCreateRequestRequestSchema">V10PresentationCreateRequestRequestSchema</a></li>
<li>aries_cloudagent.utils.tracing.AdminAPIMessageTracingSchema</li>
<li>aries_cloudagent.messaging.models.openapi.OpenAPISchema</li>
<li>marshmallow.schema.Schema</li>
<li>marshmallow.base.SchemaABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.routes.V10PresentationSendRequestRequestSchema.opts"><code class="name">var <span class="ident">opts</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="mydata_did.patched_protocols.present_proof.v1_0" href="index.html">mydata_did.patched_protocols.present_proof.v1_0</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="mydata_did.patched_protocols.present_proof.v1_0.routes.post_process_routes" href="#mydata_did.patched_protocols.present_proof.v1_0.routes.post_process_routes">post_process_routes</a></code></li>
<li><code><a title="mydata_did.patched_protocols.present_proof.v1_0.routes.presentation_exchange_create_request" href="#mydata_did.patched_protocols.present_proof.v1_0.routes.presentation_exchange_create_request">presentation_exchange_create_request</a></code></li>
<li><code><a title="mydata_did.patched_protocols.present_proof.v1_0.routes.presentation_exchange_credentials_list" href="#mydata_did.patched_protocols.present_proof.v1_0.routes.presentation_exchange_credentials_list">presentation_exchange_credentials_list</a></code></li>
<li><code><a title="mydata_did.patched_protocols.present_proof.v1_0.routes.presentation_exchange_list" href="#mydata_did.patched_protocols.present_proof.v1_0.routes.presentation_exchange_list">presentation_exchange_list</a></code></li>
<li><code><a title="mydata_did.patched_protocols.present_proof.v1_0.routes.presentation_exchange_remove" href="#mydata_did.patched_protocols.present_proof.v1_0.routes.presentation_exchange_remove">presentation_exchange_remove</a></code></li>
<li><code><a title="mydata_did.patched_protocols.present_proof.v1_0.routes.presentation_exchange_retrieve" href="#mydata_did.patched_protocols.present_proof.v1_0.routes.presentation_exchange_retrieve">presentation_exchange_retrieve</a></code></li>
<li><code><a title="mydata_did.patched_protocols.present_proof.v1_0.routes.presentation_exchange_send_bound_request" href="#mydata_did.patched_protocols.present_proof.v1_0.routes.presentation_exchange_send_bound_request">presentation_exchange_send_bound_request</a></code></li>
<li><code><a title="mydata_did.patched_protocols.present_proof.v1_0.routes.presentation_exchange_send_free_request" href="#mydata_did.patched_protocols.present_proof.v1_0.routes.presentation_exchange_send_free_request">presentation_exchange_send_free_request</a></code></li>
<li><code><a title="mydata_did.patched_protocols.present_proof.v1_0.routes.presentation_exchange_send_presentation" href="#mydata_did.patched_protocols.present_proof.v1_0.routes.presentation_exchange_send_presentation">presentation_exchange_send_presentation</a></code></li>
<li><code><a title="mydata_did.patched_protocols.present_proof.v1_0.routes.presentation_exchange_send_proposal" href="#mydata_did.patched_protocols.present_proof.v1_0.routes.presentation_exchange_send_proposal">presentation_exchange_send_proposal</a></code></li>
<li><code><a title="mydata_did.patched_protocols.present_proof.v1_0.routes.presentation_exchange_verify_presentation" href="#mydata_did.patched_protocols.present_proof.v1_0.routes.presentation_exchange_verify_presentation">presentation_exchange_verify_presentation</a></code></li>
<li><code><a title="mydata_did.patched_protocols.present_proof.v1_0.routes.register" href="#mydata_did.patched_protocols.present_proof.v1_0.routes.register">register</a></code></li>
<li><code><a title="mydata_did.patched_protocols.present_proof.v1_0.routes.send_presentation_request_for_data_agreement" href="#mydata_did.patched_protocols.present_proof.v1_0.routes.send_presentation_request_for_data_agreement">send_presentation_request_for_data_agreement</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="mydata_did.patched_protocols.present_proof.v1_0.routes.CredentialsFetchQueryStringSchema" href="#mydata_did.patched_protocols.present_proof.v1_0.routes.CredentialsFetchQueryStringSchema">CredentialsFetchQueryStringSchema</a></code></h4>
<ul class="">
<li><code><a title="mydata_did.patched_protocols.present_proof.v1_0.routes.CredentialsFetchQueryStringSchema.opts" href="#mydata_did.patched_protocols.present_proof.v1_0.routes.CredentialsFetchQueryStringSchema.opts">opts</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mydata_did.patched_protocols.present_proof.v1_0.routes.DAIndyProofReqAttrSpecSchema" href="#mydata_did.patched_protocols.present_proof.v1_0.routes.DAIndyProofReqAttrSpecSchema">DAIndyProofReqAttrSpecSchema</a></code></h4>
<ul class="">
<li><code><a title="mydata_did.patched_protocols.present_proof.v1_0.routes.DAIndyProofReqAttrSpecSchema.opts" href="#mydata_did.patched_protocols.present_proof.v1_0.routes.DAIndyProofReqAttrSpecSchema.opts">opts</a></code></li>
<li><code><a title="mydata_did.patched_protocols.present_proof.v1_0.routes.DAIndyProofReqAttrSpecSchema.validate_fields" href="#mydata_did.patched_protocols.present_proof.v1_0.routes.DAIndyProofReqAttrSpecSchema.validate_fields">validate_fields</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mydata_did.patched_protocols.present_proof.v1_0.routes.DAIndyProofReqNonRevokedSchema" href="#mydata_did.patched_protocols.present_proof.v1_0.routes.DAIndyProofReqNonRevokedSchema">DAIndyProofReqNonRevokedSchema</a></code></h4>
<ul class="">
<li><code><a title="mydata_did.patched_protocols.present_proof.v1_0.routes.DAIndyProofReqNonRevokedSchema.opts" href="#mydata_did.patched_protocols.present_proof.v1_0.routes.DAIndyProofReqNonRevokedSchema.opts">opts</a></code></li>
<li><code><a title="mydata_did.patched_protocols.present_proof.v1_0.routes.DAIndyProofReqNonRevokedSchema.validate_fields" href="#mydata_did.patched_protocols.present_proof.v1_0.routes.DAIndyProofReqNonRevokedSchema.validate_fields">validate_fields</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mydata_did.patched_protocols.present_proof.v1_0.routes.DAIndyProofReqPredSpecRestrictionsSchema" href="#mydata_did.patched_protocols.present_proof.v1_0.routes.DAIndyProofReqPredSpecRestrictionsSchema">DAIndyProofReqPredSpecRestrictionsSchema</a></code></h4>
<ul class="">
<li><code><a title="mydata_did.patched_protocols.present_proof.v1_0.routes.DAIndyProofReqPredSpecRestrictionsSchema.opts" href="#mydata_did.patched_protocols.present_proof.v1_0.routes.DAIndyProofReqPredSpecRestrictionsSchema.opts">opts</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mydata_did.patched_protocols.present_proof.v1_0.routes.DAIndyProofReqPredSpecSchema" href="#mydata_did.patched_protocols.present_proof.v1_0.routes.DAIndyProofReqPredSpecSchema">DAIndyProofReqPredSpecSchema</a></code></h4>
<ul class="">
<li><code><a title="mydata_did.patched_protocols.present_proof.v1_0.routes.DAIndyProofReqPredSpecSchema.opts" href="#mydata_did.patched_protocols.present_proof.v1_0.routes.DAIndyProofReqPredSpecSchema.opts">opts</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mydata_did.patched_protocols.present_proof.v1_0.routes.DAIndyProofRequestSchema" href="#mydata_did.patched_protocols.present_proof.v1_0.routes.DAIndyProofRequestSchema">DAIndyProofRequestSchema</a></code></h4>
<ul class="">
<li><code><a title="mydata_did.patched_protocols.present_proof.v1_0.routes.DAIndyProofRequestSchema.opts" href="#mydata_did.patched_protocols.present_proof.v1_0.routes.DAIndyProofRequestSchema.opts">opts</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mydata_did.patched_protocols.present_proof.v1_0.routes.IndyRequestedCredsRequestedAttrSchema" href="#mydata_did.patched_protocols.present_proof.v1_0.routes.IndyRequestedCredsRequestedAttrSchema">IndyRequestedCredsRequestedAttrSchema</a></code></h4>
<ul class="">
<li><code><a title="mydata_did.patched_protocols.present_proof.v1_0.routes.IndyRequestedCredsRequestedAttrSchema.opts" href="#mydata_did.patched_protocols.present_proof.v1_0.routes.IndyRequestedCredsRequestedAttrSchema.opts">opts</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mydata_did.patched_protocols.present_proof.v1_0.routes.IndyRequestedCredsRequestedPredSchema" href="#mydata_did.patched_protocols.present_proof.v1_0.routes.IndyRequestedCredsRequestedPredSchema">IndyRequestedCredsRequestedPredSchema</a></code></h4>
<ul class="">
<li><code><a title="mydata_did.patched_protocols.present_proof.v1_0.routes.IndyRequestedCredsRequestedPredSchema.opts" href="#mydata_did.patched_protocols.present_proof.v1_0.routes.IndyRequestedCredsRequestedPredSchema.opts">opts</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mydata_did.patched_protocols.present_proof.v1_0.routes.PresExIdMatchInfoSchema" href="#mydata_did.patched_protocols.present_proof.v1_0.routes.PresExIdMatchInfoSchema">PresExIdMatchInfoSchema</a></code></h4>
<ul class="">
<li><code><a title="mydata_did.patched_protocols.present_proof.v1_0.routes.PresExIdMatchInfoSchema.opts" href="#mydata_did.patched_protocols.present_proof.v1_0.routes.PresExIdMatchInfoSchema.opts">opts</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mydata_did.patched_protocols.present_proof.v1_0.routes.SendPresentationRequestForDataAgreementRequestSchema" href="#mydata_did.patched_protocols.present_proof.v1_0.routes.SendPresentationRequestForDataAgreementRequestSchema">SendPresentationRequestForDataAgreementRequestSchema</a></code></h4>
<ul class="">
<li><code><a title="mydata_did.patched_protocols.present_proof.v1_0.routes.SendPresentationRequestForDataAgreementRequestSchema.opts" href="#mydata_did.patched_protocols.present_proof.v1_0.routes.SendPresentationRequestForDataAgreementRequestSchema.opts">opts</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mydata_did.patched_protocols.present_proof.v1_0.routes.V10PresentationCreateRequestRequestSchema" href="#mydata_did.patched_protocols.present_proof.v1_0.routes.V10PresentationCreateRequestRequestSchema">V10PresentationCreateRequestRequestSchema</a></code></h4>
<ul class="">
<li><code><a title="mydata_did.patched_protocols.present_proof.v1_0.routes.V10PresentationCreateRequestRequestSchema.opts" href="#mydata_did.patched_protocols.present_proof.v1_0.routes.V10PresentationCreateRequestRequestSchema.opts">opts</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mydata_did.patched_protocols.present_proof.v1_0.routes.V10PresentationExchangeListQueryStringSchema" href="#mydata_did.patched_protocols.present_proof.v1_0.routes.V10PresentationExchangeListQueryStringSchema">V10PresentationExchangeListQueryStringSchema</a></code></h4>
<ul class="">
<li><code><a title="mydata_did.patched_protocols.present_proof.v1_0.routes.V10PresentationExchangeListQueryStringSchema.opts" href="#mydata_did.patched_protocols.present_proof.v1_0.routes.V10PresentationExchangeListQueryStringSchema.opts">opts</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mydata_did.patched_protocols.present_proof.v1_0.routes.V10PresentationExchangeListSchema" href="#mydata_did.patched_protocols.present_proof.v1_0.routes.V10PresentationExchangeListSchema">V10PresentationExchangeListSchema</a></code></h4>
<ul class="">
<li><code><a title="mydata_did.patched_protocols.present_proof.v1_0.routes.V10PresentationExchangeListSchema.opts" href="#mydata_did.patched_protocols.present_proof.v1_0.routes.V10PresentationExchangeListSchema.opts">opts</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mydata_did.patched_protocols.present_proof.v1_0.routes.V10PresentationProposalRequestSchema" href="#mydata_did.patched_protocols.present_proof.v1_0.routes.V10PresentationProposalRequestSchema">V10PresentationProposalRequestSchema</a></code></h4>
<ul class="">
<li><code><a title="mydata_did.patched_protocols.present_proof.v1_0.routes.V10PresentationProposalRequestSchema.opts" href="#mydata_did.patched_protocols.present_proof.v1_0.routes.V10PresentationProposalRequestSchema.opts">opts</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mydata_did.patched_protocols.present_proof.v1_0.routes.V10PresentationRequestSchema" href="#mydata_did.patched_protocols.present_proof.v1_0.routes.V10PresentationRequestSchema">V10PresentationRequestSchema</a></code></h4>
<ul class="">
<li><code><a title="mydata_did.patched_protocols.present_proof.v1_0.routes.V10PresentationRequestSchema.opts" href="#mydata_did.patched_protocols.present_proof.v1_0.routes.V10PresentationRequestSchema.opts">opts</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mydata_did.patched_protocols.present_proof.v1_0.routes.V10PresentationSendRequestRequestSchema" href="#mydata_did.patched_protocols.present_proof.v1_0.routes.V10PresentationSendRequestRequestSchema">V10PresentationSendRequestRequestSchema</a></code></h4>
<ul class="">
<li><code><a title="mydata_did.patched_protocols.present_proof.v1_0.routes.V10PresentationSendRequestRequestSchema.opts" href="#mydata_did.patched_protocols.present_proof.v1_0.routes.V10PresentationSendRequestRequestSchema.opts">opts</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>