<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>mydata_did.patched_protocols.present_proof.v1_0.manager API documentation</title>
<meta name="description" content="Classes to manage presentations." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>mydata_did.patched_protocols.present_proof.v1_0.manager</code></h1>
</header>
<section id="section-intro">
<p>Classes to manage presentations.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Classes to manage presentations.&#34;&#34;&#34;

import json
import logging
import time

from aries_cloudagent.revocation.models.revocation_registry import RevocationRegistry
from aries_cloudagent.config.injection_context import InjectionContext
from aries_cloudagent.core.error import BaseError
from aries_cloudagent.holder.base import BaseHolder, HolderError
from aries_cloudagent.ledger.base import BaseLedger
from aries_cloudagent.messaging.decorators.attach_decorator import AttachDecorator
from aries_cloudagent.messaging.responder import BaseResponder
from aries_cloudagent.verifier.base import BaseVerifier

from .models.presentation_exchange import V10PresentationExchange
from .messages.presentation_ack import PresentationAck
from .messages.presentation_proposal import PresentationProposal
from .messages.presentation_request import PresentationRequest
from .messages.presentation import Presentation
from .message_types import ATTACH_DECO_IDS, PRESENTATION, PRESENTATION_REQUEST

LOGGER = logging.getLogger(__name__)


class PresentationManagerError(BaseError):
    &#34;&#34;&#34;Presentation error.&#34;&#34;&#34;


class PresentationManager:
    &#34;&#34;&#34;Class for managing presentations.&#34;&#34;&#34;

    def __init__(self, context: InjectionContext):
        &#34;&#34;&#34;
        Initialize a PresentationManager.

        Args:
            context: The context for this presentation
        &#34;&#34;&#34;

        self._context = context

    @property
    def context(self) -&gt; InjectionContext:
        &#34;&#34;&#34;
        Accessor for the current request context.

        Returns:
            The injection context for this presentation manager

        &#34;&#34;&#34;
        return self._context

    async def create_exchange_for_proposal(
        self,
        connection_id: str,
        presentation_proposal_message: PresentationProposal,
        auto_present: bool = None,
    ):
        &#34;&#34;&#34;
        Create a presentation exchange record for input presentation proposal.

        Args:
            connection_id: connection identifier
            presentation_proposal_message: presentation proposal to serialize
                to exchange record
            auto_present: whether to present proof upon receiving proof request
                (default to configuration setting)

        Returns:
            Presentation exchange record, created

        &#34;&#34;&#34;
        presentation_exchange_record = V10PresentationExchange(
            connection_id=connection_id,
            thread_id=presentation_proposal_message._thread_id,
            initiator=V10PresentationExchange.INITIATOR_SELF,
            role=V10PresentationExchange.ROLE_PROVER,
            state=V10PresentationExchange.STATE_PROPOSAL_SENT,
            presentation_proposal_dict=presentation_proposal_message.serialize(),
            auto_present=auto_present,
            trace=(presentation_proposal_message._trace is not None),
        )
        await presentation_exchange_record.save(
            self.context, reason=&#34;create presentation proposal&#34;
        )

        return presentation_exchange_record

    async def receive_proposal(self):
        &#34;&#34;&#34;
        Receive a presentation proposal from message in context on manager creation.

        Returns:
            Presentation exchange record, created

        &#34;&#34;&#34;
        presentation_proposal_message = self.context.message
        presentation_exchange_record = V10PresentationExchange(
            connection_id=self.context.connection_record.connection_id,
            thread_id=presentation_proposal_message._thread_id,
            initiator=V10PresentationExchange.INITIATOR_EXTERNAL,
            role=V10PresentationExchange.ROLE_VERIFIER,
            state=V10PresentationExchange.STATE_PROPOSAL_RECEIVED,
            presentation_proposal_dict=presentation_proposal_message.serialize(),
            trace=(presentation_proposal_message._trace is not None),
        )
        await presentation_exchange_record.save(
            self.context, reason=&#34;receive presentation request&#34;
        )

        return presentation_exchange_record

    async def create_bound_request(
        self,
        presentation_exchange_record: V10PresentationExchange,
        name: str = None,
        version: str = None,
        nonce: str = None,
        comment: str = None,
    ):
        &#34;&#34;&#34;
        Create a presentation request bound to a proposal.

        Args:
            presentation_exchange_record: Presentation exchange record for which
                to create presentation request
            name: name to use in presentation request (None for default)
            version: version to use in presentation request (None for default)
            nonce: nonce to use in presentation request (None to generate)
            comment: Optional human-readable comment pertaining to request creation

        Returns:
            A tuple (updated presentation exchange record, presentation request message)

        &#34;&#34;&#34;
        indy_proof_request = await (
            PresentationProposal.deserialize(
                presentation_exchange_record.presentation_proposal_dict
            )
        ).presentation_proposal.indy_proof_request(
            name=name,
            version=version,
            nonce=nonce,
            ledger=await self.context.inject(BaseLedger),
        )
        presentation_request_message = PresentationRequest(
            comment=comment,
            request_presentations_attach=[
                AttachDecorator.from_indy_dict(
                    indy_dict=indy_proof_request,
                    ident=ATTACH_DECO_IDS[PRESENTATION_REQUEST],
                )
            ],
        )
        presentation_request_message._thread = {
            &#34;thid&#34;: presentation_exchange_record.thread_id
        }
        presentation_request_message.assign_trace_decorator(
            self.context.settings, presentation_exchange_record.trace
        )

        presentation_exchange_record.thread_id = presentation_request_message._thread_id
        presentation_exchange_record.state = V10PresentationExchange.STATE_REQUEST_SENT
        presentation_exchange_record.presentation_request = indy_proof_request
        await presentation_exchange_record.save(
            self.context, reason=&#34;create (bound) presentation request&#34;
        )

        return presentation_exchange_record, presentation_request_message

    async def create_exchange_for_request(
        self, connection_id: str, presentation_request_message: PresentationRequest
    ):
        &#34;&#34;&#34;
        Create a presentation exchange record for input presentation request.

        Args:
            connection_id: connection identifier
            presentation_request_message: presentation request to use in creating
                exchange record, extracting indy proof request and thread id

        Returns:
            Presentation exchange record, updated

        &#34;&#34;&#34;
        presentation_exchange_record = V10PresentationExchange(
            connection_id=connection_id,
            thread_id=presentation_request_message._thread_id,
            initiator=V10PresentationExchange.INITIATOR_SELF,
            role=V10PresentationExchange.ROLE_VERIFIER,
            state=V10PresentationExchange.STATE_REQUEST_SENT,
            presentation_request=presentation_request_message.indy_proof_request(),
            presentation_request_dict=presentation_request_message.serialize(),
            trace=(presentation_request_message._trace is not None),
        )
        await presentation_exchange_record.save(
            self.context, reason=&#34;create (free) presentation request&#34;
        )

        return presentation_exchange_record

    async def receive_request(
        self, presentation_exchange_record: V10PresentationExchange
    ):
        &#34;&#34;&#34;
        Receive a presentation request.

        Args:
            presentation_exchange_record: presentation exchange record with
                request to receive

        Returns:
            The presentation_exchange_record, updated

        &#34;&#34;&#34;
        presentation_exchange_record.state = (
            V10PresentationExchange.STATE_REQUEST_RECEIVED
        )
        await presentation_exchange_record.save(
            self.context, reason=&#34;receive presentation request&#34;
        )

        return presentation_exchange_record

    async def create_presentation(
        self,
        presentation_exchange_record: V10PresentationExchange,
        requested_credentials: dict,
        comment: str = None,
    ):
        &#34;&#34;&#34;
        Create a presentation.

        Args:
            presentation_exchange_record: Record to update
            requested_credentials: Indy formatted requested_credentials
            comment: optional human-readable comment


        Example `requested_credentials` format:

        ::

            {
                &#34;self_attested_attributes&#34;: {
                    &#34;j233ffbc-bd35-49b1-934f-51e083106f6d&#34;: &#34;value&#34;
                },
                &#34;requested_attributes&#34;: {
                    &#34;6253ffbb-bd35-49b3-934f-46e083106f6c&#34;: {
                        &#34;cred_id&#34;: &#34;5bfa40b7-062b-4ae0-a251-a86c87922c0e&#34;,
                        &#34;revealed&#34;: true
                    }
                },
                &#34;requested_predicates&#34;: {
                    &#34;bfc8a97d-60d3-4f21-b998-85eeabe5c8c0&#34;: {
                        &#34;cred_id&#34;: &#34;5bfa40b7-062b-4ae0-a251-a86c87922c0e&#34;
                    }
                }
            }

        Returns:
            A tuple (updated presentation exchange record, presentation message)

        &#34;&#34;&#34;
        # Get all credentials for this presentation
        holder: BaseHolder = await self.context.inject(BaseHolder)
        credentials = {}

        # extract credential ids and non_revoked
        requested_referents = {}
        presentation_request = presentation_exchange_record.presentation_request
        attr_creds = requested_credentials.get(&#34;requested_attributes&#34;, {})
        req_attrs = presentation_request.get(&#34;requested_attributes&#34;, {})
        for referent in attr_creds:
            requested_referents[referent] = {&#34;cred_id&#34;: attr_creds[referent][&#34;cred_id&#34;]}
            if referent in req_attrs and &#34;non_revoked&#34; in req_attrs[referent]:
                requested_referents[referent][&#34;non_revoked&#34;] = req_attrs[referent][
                    &#34;non_revoked&#34;
                ]

        preds_creds = requested_credentials.get(&#34;requested_predicates&#34;, {})
        req_preds = presentation_request.get(&#34;requested_predicates&#34;, {})
        for referent in preds_creds:
            requested_referents[referent] = {
                &#34;cred_id&#34;: preds_creds[referent][&#34;cred_id&#34;]
            }
            if referent in req_preds and &#34;non_revoked&#34; in req_preds[referent]:
                requested_referents[referent][&#34;non_revoked&#34;] = req_preds[referent][
                    &#34;non_revoked&#34;
                ]

        # extract mapping of presentation referents to credential ids
        for referent in requested_referents:
            credential_id = requested_referents[referent][&#34;cred_id&#34;]
            if credential_id not in credentials:
                credentials[credential_id] = json.loads(
                    await holder.get_credential(credential_id)
                )

        # Get all schema, credential definition, and revocation registry in use
        ledger: BaseLedger = await self.context.inject(BaseLedger)
        schemas = {}
        credential_definitions = {}
        revocation_registries = {}

        async with ledger:
            for credential in credentials.values():
                schema_id = credential[&#34;schema_id&#34;]
                if schema_id not in schemas:
                    schemas[schema_id] = await ledger.get_schema(schema_id)

                credential_definition_id = credential[&#34;cred_def_id&#34;]
                if credential_definition_id not in credential_definitions:
                    credential_definitions[
                        credential_definition_id
                    ] = await ledger.get_credential_definition(credential_definition_id)

                if credential.get(&#34;rev_reg_id&#34;):
                    revocation_registry_id = credential[&#34;rev_reg_id&#34;]
                    if revocation_registry_id not in revocation_registries:
                        revocation_registries[
                            revocation_registry_id
                        ] = RevocationRegistry.from_definition(
                            await ledger.get_revoc_reg_def(revocation_registry_id), True
                        )

        # Get delta with non-revocation interval defined in &#34;non_revoked&#34;
        # of the presentation request or attributes
        epoch_now = int(time.time())

        non_revoc_interval = {&#34;from&#34;: 0, &#34;to&#34;: epoch_now}
        non_revoc_interval.update(
            presentation_exchange_record.presentation_request.get(&#34;non_revoked&#34;) or {}
        )

        revoc_reg_deltas = {}
        async with ledger:
            for precis in requested_referents.values():  # cred_id, non-revoc interval
                credential_id = precis[&#34;cred_id&#34;]
                if not credentials[credential_id].get(&#34;rev_reg_id&#34;):
                    continue
                if &#34;timestamp&#34; in precis:
                    continue
                rev_reg_id = credentials[credential_id][&#34;rev_reg_id&#34;]
                referent_non_revoc_interval = precis.get(
                    &#34;non_revoked&#34;, non_revoc_interval
                )

                if referent_non_revoc_interval:
                    key = (
                        f&#34;{rev_reg_id}_{referent_non_revoc_interval.get(&#39;from&#39;, 0)}_&#34;
                        f&#34;{referent_non_revoc_interval.get(&#39;to&#39;, epoch_now)}&#34;
                    )
                    if key not in revoc_reg_deltas:
                        (delta, delta_timestamp) = await ledger.get_revoc_reg_delta(
                            rev_reg_id,
                            referent_non_revoc_interval.get(&#34;from&#34;, 0),
                            referent_non_revoc_interval.get(&#34;to&#34;, epoch_now),
                        )
                        revoc_reg_deltas[key] = (
                            rev_reg_id,
                            credential_id,
                            delta,
                            delta_timestamp,
                        )
                    for stamp_me in requested_referents.values():
                        # often one cred satisfies many requested attrs/preds
                        if stamp_me[&#34;cred_id&#34;] == credential_id:
                            stamp_me[&#34;timestamp&#34;] = revoc_reg_deltas[key][3]

        # Get revocation states to prove non-revoked
        revocation_states = {}
        for (
            rev_reg_id,
            credential_id,
            delta,
            delta_timestamp,
        ) in revoc_reg_deltas.values():
            if rev_reg_id not in revocation_states:
                revocation_states[rev_reg_id] = {}

            rev_reg = revocation_registries[rev_reg_id]
            tails_local_path = await rev_reg.get_or_fetch_local_tails_path()

            try:
                revocation_states[rev_reg_id][delta_timestamp] = json.loads(
                    await holder.create_revocation_state(
                        credentials[credential_id][&#34;cred_rev_id&#34;],
                        rev_reg.reg_def,
                        delta,
                        delta_timestamp,
                        tails_local_path,
                    )
                )
            except HolderError as e:
                LOGGER.error(
                    f&#34;Failed to create revocation state: {e.error_code}, {e.message}&#34;
                )
                raise e

        for (referent, precis) in requested_referents.items():
            if &#34;timestamp&#34; not in precis:
                continue
            if referent in requested_credentials[&#34;requested_attributes&#34;]:
                requested_credentials[&#34;requested_attributes&#34;][referent][
                    &#34;timestamp&#34;
                ] = precis[&#34;timestamp&#34;]
            if referent in requested_credentials[&#34;requested_predicates&#34;]:
                requested_credentials[&#34;requested_predicates&#34;][referent][
                    &#34;timestamp&#34;
                ] = precis[&#34;timestamp&#34;]

        indy_proof_json = await holder.create_presentation(
            presentation_exchange_record.presentation_request,
            requested_credentials,
            schemas,
            credential_definitions,
            revocation_states,
        )
        indy_proof = json.loads(indy_proof_json)

        presentation_message = Presentation(
            comment=comment,
            presentations_attach=[
                AttachDecorator.from_indy_dict(
                    indy_dict=indy_proof, ident=ATTACH_DECO_IDS[PRESENTATION]
                )
            ],
        )

        presentation_message._thread = {&#34;thid&#34;: presentation_exchange_record.thread_id}
        presentation_message.assign_trace_decorator(
            self.context.settings, presentation_exchange_record.trace
        )

        # save presentation exchange state
        presentation_exchange_record.state = (
            V10PresentationExchange.STATE_PRESENTATION_SENT
        )
        presentation_exchange_record.presentation = indy_proof
        await presentation_exchange_record.save(
            self.context, reason=&#34;create presentation&#34;
        )

        return presentation_exchange_record, presentation_message

    async def receive_presentation(self):
        &#34;&#34;&#34;
        Receive a presentation, from message in context on manager creation.

        Returns:
            presentation exchange record, retrieved and updated

        &#34;&#34;&#34;
        presentation = self.context.message.indy_proof()

        thread_id = self.context.message._thread_id
        connection_id_filter = (
            {&#34;connection_id&#34;: self.context.connection_record.connection_id}
            if self.context.connection_record is not None
            else None
        )
        (
            presentation_exchange_record
        ) = await V10PresentationExchange.retrieve_by_tag_filter(
            self.context, {&#34;thread_id&#34;: thread_id}, connection_id_filter
        )

        # Check for bait-and-switch in presented attribute values vs. proposal
        if presentation_exchange_record.presentation_proposal_dict:
            exchange_pres_proposal = PresentationProposal.deserialize(
                presentation_exchange_record.presentation_proposal_dict
            )
            presentation_preview = exchange_pres_proposal.presentation_proposal

            proof_req = presentation_exchange_record.presentation_request
            for (reft, attr_spec) in presentation[&#34;requested_proof&#34;][
                &#34;revealed_attrs&#34;
            ].items():
                name = proof_req[&#34;requested_attributes&#34;][reft][&#34;name&#34;]
                value = attr_spec[&#34;raw&#34;]
                if not presentation_preview.has_attr_spec(
                    cred_def_id=presentation[&#34;identifiers&#34;][
                        attr_spec[&#34;sub_proof_index&#34;]
                    ][&#34;cred_def_id&#34;],
                    name=name,
                    value=value,
                ):
                    raise PresentationManagerError(
                        f&#34;Presentation {name}={value} mismatches proposal value&#34;
                    )

        presentation_exchange_record.presentation = presentation
        presentation_exchange_record.state = (
            V10PresentationExchange.STATE_PRESENTATION_RECEIVED
        )

        await presentation_exchange_record.save(
            self.context, reason=&#34;receive presentation&#34;
        )

        return presentation_exchange_record

    async def verify_presentation(
        self, presentation_exchange_record: V10PresentationExchange
    ):
        &#34;&#34;&#34;
        Verify a presentation.

        Args:
            presentation_exchange_record: presentation exchange record
                with presentation request and presentation to verify

        Returns:
            presentation record, updated

        &#34;&#34;&#34;
        indy_proof_request = presentation_exchange_record.presentation_request
        indy_proof = presentation_exchange_record.presentation

        schema_ids = []
        credential_definition_ids = []

        schemas = {}
        credential_definitions = {}
        rev_reg_defs = {}
        rev_reg_entries = {}

        identifiers = indy_proof[&#34;identifiers&#34;]
        ledger: BaseLedger = await self.context.inject(BaseLedger)
        async with ledger:
            for identifier in identifiers:
                schema_ids.append(identifier[&#34;schema_id&#34;])
                credential_definition_ids.append(identifier[&#34;cred_def_id&#34;])

                # Build schemas for anoncreds
                if identifier[&#34;schema_id&#34;] not in schemas:
                    schemas[identifier[&#34;schema_id&#34;]] = await ledger.get_schema(
                        identifier[&#34;schema_id&#34;]
                    )

                if identifier[&#34;cred_def_id&#34;] not in credential_definitions:
                    credential_definitions[
                        identifier[&#34;cred_def_id&#34;]
                    ] = await ledger.get_credential_definition(
                        identifier[&#34;cred_def_id&#34;]
                    )

                if identifier.get(&#34;rev_reg_id&#34;):
                    if identifier[&#34;rev_reg_id&#34;] not in rev_reg_defs:
                        rev_reg_defs[
                            identifier[&#34;rev_reg_id&#34;]
                        ] = await ledger.get_revoc_reg_def(identifier[&#34;rev_reg_id&#34;])

                    if identifier.get(&#34;timestamp&#34;):
                        rev_reg_entries.setdefault(identifier[&#34;rev_reg_id&#34;], {})

                        if (
                            identifier[&#34;timestamp&#34;]
                            not in rev_reg_entries[identifier[&#34;rev_reg_id&#34;]]
                        ):
                            (
                                found_rev_reg_entry,
                                _found_timestamp,
                            ) = await ledger.get_revoc_reg_entry(
                                identifier[&#34;rev_reg_id&#34;], identifier[&#34;timestamp&#34;]
                            )
                            rev_reg_entries[identifier[&#34;rev_reg_id&#34;]][
                                identifier[&#34;timestamp&#34;]
                            ] = found_rev_reg_entry

        verifier: BaseVerifier = await self.context.inject(BaseVerifier)
        presentation_exchange_record.verified = json.dumps(  # tag: needs string value
            await verifier.verify_presentation(
                indy_proof_request,
                indy_proof,
                schemas,
                credential_definitions,
                rev_reg_defs,
                rev_reg_entries,
            )
        )
        presentation_exchange_record.state = V10PresentationExchange.STATE_VERIFIED

        await presentation_exchange_record.save(
            self.context, reason=&#34;verify presentation&#34;
        )

        await self.send_presentation_ack(presentation_exchange_record)
        return presentation_exchange_record

    async def send_presentation_ack(
        self, presentation_exchange_record: V10PresentationExchange
    ):
        &#34;&#34;&#34;
        Send acknowledgement of presentation receipt.

        Args:
            presentation_exchange_record: presentation exchange record with thread id

        &#34;&#34;&#34;
        responder = await self.context.inject(BaseResponder, required=False)

        if responder:
            presentation_ack_message = PresentationAck()
            presentation_ack_message._thread = {
                &#34;thid&#34;: presentation_exchange_record.thread_id
            }
            presentation_ack_message.assign_trace_decorator(
                self.context.settings, presentation_exchange_record.trace
            )

            await responder.send_reply(
                presentation_ack_message,
                connection_id=presentation_exchange_record.connection_id,
            )
        else:
            LOGGER.warning(
                &#34;Configuration has no BaseResponder: cannot ack presentation on %s&#34;,
                presentation_exchange_record.thread_id,
            )

    async def receive_presentation_ack(self):
        &#34;&#34;&#34;
        Receive a presentation ack, from message in context on manager creation.

        Returns:
            presentation exchange record, retrieved and updated

        &#34;&#34;&#34;
        (
            presentation_exchange_record
        ) = await V10PresentationExchange.retrieve_by_tag_filter(
            self.context,
            {&#34;thread_id&#34;: self.context.message._thread_id},
            {&#34;connection_id&#34;: self.context.connection_record.connection_id},
        )

        presentation_exchange_record.state = (
            V10PresentationExchange.STATE_PRESENTATION_ACKED
        )

        await presentation_exchange_record.save(
            self.context, reason=&#34;receive presentation ack&#34;
        )

        return presentation_exchange_record</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.manager.PresentationManager"><code class="flex name class">
<span>class <span class="ident">PresentationManager</span></span>
<span>(</span><span>context:Â aries_cloudagent.config.injection_context.InjectionContext)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for managing presentations.</p>
<p>Initialize a PresentationManager.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>context</code></strong></dt>
<dd>The context for this presentation</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PresentationManager:
    &#34;&#34;&#34;Class for managing presentations.&#34;&#34;&#34;

    def __init__(self, context: InjectionContext):
        &#34;&#34;&#34;
        Initialize a PresentationManager.

        Args:
            context: The context for this presentation
        &#34;&#34;&#34;

        self._context = context

    @property
    def context(self) -&gt; InjectionContext:
        &#34;&#34;&#34;
        Accessor for the current request context.

        Returns:
            The injection context for this presentation manager

        &#34;&#34;&#34;
        return self._context

    async def create_exchange_for_proposal(
        self,
        connection_id: str,
        presentation_proposal_message: PresentationProposal,
        auto_present: bool = None,
    ):
        &#34;&#34;&#34;
        Create a presentation exchange record for input presentation proposal.

        Args:
            connection_id: connection identifier
            presentation_proposal_message: presentation proposal to serialize
                to exchange record
            auto_present: whether to present proof upon receiving proof request
                (default to configuration setting)

        Returns:
            Presentation exchange record, created

        &#34;&#34;&#34;
        presentation_exchange_record = V10PresentationExchange(
            connection_id=connection_id,
            thread_id=presentation_proposal_message._thread_id,
            initiator=V10PresentationExchange.INITIATOR_SELF,
            role=V10PresentationExchange.ROLE_PROVER,
            state=V10PresentationExchange.STATE_PROPOSAL_SENT,
            presentation_proposal_dict=presentation_proposal_message.serialize(),
            auto_present=auto_present,
            trace=(presentation_proposal_message._trace is not None),
        )
        await presentation_exchange_record.save(
            self.context, reason=&#34;create presentation proposal&#34;
        )

        return presentation_exchange_record

    async def receive_proposal(self):
        &#34;&#34;&#34;
        Receive a presentation proposal from message in context on manager creation.

        Returns:
            Presentation exchange record, created

        &#34;&#34;&#34;
        presentation_proposal_message = self.context.message
        presentation_exchange_record = V10PresentationExchange(
            connection_id=self.context.connection_record.connection_id,
            thread_id=presentation_proposal_message._thread_id,
            initiator=V10PresentationExchange.INITIATOR_EXTERNAL,
            role=V10PresentationExchange.ROLE_VERIFIER,
            state=V10PresentationExchange.STATE_PROPOSAL_RECEIVED,
            presentation_proposal_dict=presentation_proposal_message.serialize(),
            trace=(presentation_proposal_message._trace is not None),
        )
        await presentation_exchange_record.save(
            self.context, reason=&#34;receive presentation request&#34;
        )

        return presentation_exchange_record

    async def create_bound_request(
        self,
        presentation_exchange_record: V10PresentationExchange,
        name: str = None,
        version: str = None,
        nonce: str = None,
        comment: str = None,
    ):
        &#34;&#34;&#34;
        Create a presentation request bound to a proposal.

        Args:
            presentation_exchange_record: Presentation exchange record for which
                to create presentation request
            name: name to use in presentation request (None for default)
            version: version to use in presentation request (None for default)
            nonce: nonce to use in presentation request (None to generate)
            comment: Optional human-readable comment pertaining to request creation

        Returns:
            A tuple (updated presentation exchange record, presentation request message)

        &#34;&#34;&#34;
        indy_proof_request = await (
            PresentationProposal.deserialize(
                presentation_exchange_record.presentation_proposal_dict
            )
        ).presentation_proposal.indy_proof_request(
            name=name,
            version=version,
            nonce=nonce,
            ledger=await self.context.inject(BaseLedger),
        )
        presentation_request_message = PresentationRequest(
            comment=comment,
            request_presentations_attach=[
                AttachDecorator.from_indy_dict(
                    indy_dict=indy_proof_request,
                    ident=ATTACH_DECO_IDS[PRESENTATION_REQUEST],
                )
            ],
        )
        presentation_request_message._thread = {
            &#34;thid&#34;: presentation_exchange_record.thread_id
        }
        presentation_request_message.assign_trace_decorator(
            self.context.settings, presentation_exchange_record.trace
        )

        presentation_exchange_record.thread_id = presentation_request_message._thread_id
        presentation_exchange_record.state = V10PresentationExchange.STATE_REQUEST_SENT
        presentation_exchange_record.presentation_request = indy_proof_request
        await presentation_exchange_record.save(
            self.context, reason=&#34;create (bound) presentation request&#34;
        )

        return presentation_exchange_record, presentation_request_message

    async def create_exchange_for_request(
        self, connection_id: str, presentation_request_message: PresentationRequest
    ):
        &#34;&#34;&#34;
        Create a presentation exchange record for input presentation request.

        Args:
            connection_id: connection identifier
            presentation_request_message: presentation request to use in creating
                exchange record, extracting indy proof request and thread id

        Returns:
            Presentation exchange record, updated

        &#34;&#34;&#34;
        presentation_exchange_record = V10PresentationExchange(
            connection_id=connection_id,
            thread_id=presentation_request_message._thread_id,
            initiator=V10PresentationExchange.INITIATOR_SELF,
            role=V10PresentationExchange.ROLE_VERIFIER,
            state=V10PresentationExchange.STATE_REQUEST_SENT,
            presentation_request=presentation_request_message.indy_proof_request(),
            presentation_request_dict=presentation_request_message.serialize(),
            trace=(presentation_request_message._trace is not None),
        )
        await presentation_exchange_record.save(
            self.context, reason=&#34;create (free) presentation request&#34;
        )

        return presentation_exchange_record

    async def receive_request(
        self, presentation_exchange_record: V10PresentationExchange
    ):
        &#34;&#34;&#34;
        Receive a presentation request.

        Args:
            presentation_exchange_record: presentation exchange record with
                request to receive

        Returns:
            The presentation_exchange_record, updated

        &#34;&#34;&#34;
        presentation_exchange_record.state = (
            V10PresentationExchange.STATE_REQUEST_RECEIVED
        )
        await presentation_exchange_record.save(
            self.context, reason=&#34;receive presentation request&#34;
        )

        return presentation_exchange_record

    async def create_presentation(
        self,
        presentation_exchange_record: V10PresentationExchange,
        requested_credentials: dict,
        comment: str = None,
    ):
        &#34;&#34;&#34;
        Create a presentation.

        Args:
            presentation_exchange_record: Record to update
            requested_credentials: Indy formatted requested_credentials
            comment: optional human-readable comment


        Example `requested_credentials` format:

        ::

            {
                &#34;self_attested_attributes&#34;: {
                    &#34;j233ffbc-bd35-49b1-934f-51e083106f6d&#34;: &#34;value&#34;
                },
                &#34;requested_attributes&#34;: {
                    &#34;6253ffbb-bd35-49b3-934f-46e083106f6c&#34;: {
                        &#34;cred_id&#34;: &#34;5bfa40b7-062b-4ae0-a251-a86c87922c0e&#34;,
                        &#34;revealed&#34;: true
                    }
                },
                &#34;requested_predicates&#34;: {
                    &#34;bfc8a97d-60d3-4f21-b998-85eeabe5c8c0&#34;: {
                        &#34;cred_id&#34;: &#34;5bfa40b7-062b-4ae0-a251-a86c87922c0e&#34;
                    }
                }
            }

        Returns:
            A tuple (updated presentation exchange record, presentation message)

        &#34;&#34;&#34;
        # Get all credentials for this presentation
        holder: BaseHolder = await self.context.inject(BaseHolder)
        credentials = {}

        # extract credential ids and non_revoked
        requested_referents = {}
        presentation_request = presentation_exchange_record.presentation_request
        attr_creds = requested_credentials.get(&#34;requested_attributes&#34;, {})
        req_attrs = presentation_request.get(&#34;requested_attributes&#34;, {})
        for referent in attr_creds:
            requested_referents[referent] = {&#34;cred_id&#34;: attr_creds[referent][&#34;cred_id&#34;]}
            if referent in req_attrs and &#34;non_revoked&#34; in req_attrs[referent]:
                requested_referents[referent][&#34;non_revoked&#34;] = req_attrs[referent][
                    &#34;non_revoked&#34;
                ]

        preds_creds = requested_credentials.get(&#34;requested_predicates&#34;, {})
        req_preds = presentation_request.get(&#34;requested_predicates&#34;, {})
        for referent in preds_creds:
            requested_referents[referent] = {
                &#34;cred_id&#34;: preds_creds[referent][&#34;cred_id&#34;]
            }
            if referent in req_preds and &#34;non_revoked&#34; in req_preds[referent]:
                requested_referents[referent][&#34;non_revoked&#34;] = req_preds[referent][
                    &#34;non_revoked&#34;
                ]

        # extract mapping of presentation referents to credential ids
        for referent in requested_referents:
            credential_id = requested_referents[referent][&#34;cred_id&#34;]
            if credential_id not in credentials:
                credentials[credential_id] = json.loads(
                    await holder.get_credential(credential_id)
                )

        # Get all schema, credential definition, and revocation registry in use
        ledger: BaseLedger = await self.context.inject(BaseLedger)
        schemas = {}
        credential_definitions = {}
        revocation_registries = {}

        async with ledger:
            for credential in credentials.values():
                schema_id = credential[&#34;schema_id&#34;]
                if schema_id not in schemas:
                    schemas[schema_id] = await ledger.get_schema(schema_id)

                credential_definition_id = credential[&#34;cred_def_id&#34;]
                if credential_definition_id not in credential_definitions:
                    credential_definitions[
                        credential_definition_id
                    ] = await ledger.get_credential_definition(credential_definition_id)

                if credential.get(&#34;rev_reg_id&#34;):
                    revocation_registry_id = credential[&#34;rev_reg_id&#34;]
                    if revocation_registry_id not in revocation_registries:
                        revocation_registries[
                            revocation_registry_id
                        ] = RevocationRegistry.from_definition(
                            await ledger.get_revoc_reg_def(revocation_registry_id), True
                        )

        # Get delta with non-revocation interval defined in &#34;non_revoked&#34;
        # of the presentation request or attributes
        epoch_now = int(time.time())

        non_revoc_interval = {&#34;from&#34;: 0, &#34;to&#34;: epoch_now}
        non_revoc_interval.update(
            presentation_exchange_record.presentation_request.get(&#34;non_revoked&#34;) or {}
        )

        revoc_reg_deltas = {}
        async with ledger:
            for precis in requested_referents.values():  # cred_id, non-revoc interval
                credential_id = precis[&#34;cred_id&#34;]
                if not credentials[credential_id].get(&#34;rev_reg_id&#34;):
                    continue
                if &#34;timestamp&#34; in precis:
                    continue
                rev_reg_id = credentials[credential_id][&#34;rev_reg_id&#34;]
                referent_non_revoc_interval = precis.get(
                    &#34;non_revoked&#34;, non_revoc_interval
                )

                if referent_non_revoc_interval:
                    key = (
                        f&#34;{rev_reg_id}_{referent_non_revoc_interval.get(&#39;from&#39;, 0)}_&#34;
                        f&#34;{referent_non_revoc_interval.get(&#39;to&#39;, epoch_now)}&#34;
                    )
                    if key not in revoc_reg_deltas:
                        (delta, delta_timestamp) = await ledger.get_revoc_reg_delta(
                            rev_reg_id,
                            referent_non_revoc_interval.get(&#34;from&#34;, 0),
                            referent_non_revoc_interval.get(&#34;to&#34;, epoch_now),
                        )
                        revoc_reg_deltas[key] = (
                            rev_reg_id,
                            credential_id,
                            delta,
                            delta_timestamp,
                        )
                    for stamp_me in requested_referents.values():
                        # often one cred satisfies many requested attrs/preds
                        if stamp_me[&#34;cred_id&#34;] == credential_id:
                            stamp_me[&#34;timestamp&#34;] = revoc_reg_deltas[key][3]

        # Get revocation states to prove non-revoked
        revocation_states = {}
        for (
            rev_reg_id,
            credential_id,
            delta,
            delta_timestamp,
        ) in revoc_reg_deltas.values():
            if rev_reg_id not in revocation_states:
                revocation_states[rev_reg_id] = {}

            rev_reg = revocation_registries[rev_reg_id]
            tails_local_path = await rev_reg.get_or_fetch_local_tails_path()

            try:
                revocation_states[rev_reg_id][delta_timestamp] = json.loads(
                    await holder.create_revocation_state(
                        credentials[credential_id][&#34;cred_rev_id&#34;],
                        rev_reg.reg_def,
                        delta,
                        delta_timestamp,
                        tails_local_path,
                    )
                )
            except HolderError as e:
                LOGGER.error(
                    f&#34;Failed to create revocation state: {e.error_code}, {e.message}&#34;
                )
                raise e

        for (referent, precis) in requested_referents.items():
            if &#34;timestamp&#34; not in precis:
                continue
            if referent in requested_credentials[&#34;requested_attributes&#34;]:
                requested_credentials[&#34;requested_attributes&#34;][referent][
                    &#34;timestamp&#34;
                ] = precis[&#34;timestamp&#34;]
            if referent in requested_credentials[&#34;requested_predicates&#34;]:
                requested_credentials[&#34;requested_predicates&#34;][referent][
                    &#34;timestamp&#34;
                ] = precis[&#34;timestamp&#34;]

        indy_proof_json = await holder.create_presentation(
            presentation_exchange_record.presentation_request,
            requested_credentials,
            schemas,
            credential_definitions,
            revocation_states,
        )
        indy_proof = json.loads(indy_proof_json)

        presentation_message = Presentation(
            comment=comment,
            presentations_attach=[
                AttachDecorator.from_indy_dict(
                    indy_dict=indy_proof, ident=ATTACH_DECO_IDS[PRESENTATION]
                )
            ],
        )

        presentation_message._thread = {&#34;thid&#34;: presentation_exchange_record.thread_id}
        presentation_message.assign_trace_decorator(
            self.context.settings, presentation_exchange_record.trace
        )

        # save presentation exchange state
        presentation_exchange_record.state = (
            V10PresentationExchange.STATE_PRESENTATION_SENT
        )
        presentation_exchange_record.presentation = indy_proof
        await presentation_exchange_record.save(
            self.context, reason=&#34;create presentation&#34;
        )

        return presentation_exchange_record, presentation_message

    async def receive_presentation(self):
        &#34;&#34;&#34;
        Receive a presentation, from message in context on manager creation.

        Returns:
            presentation exchange record, retrieved and updated

        &#34;&#34;&#34;
        presentation = self.context.message.indy_proof()

        thread_id = self.context.message._thread_id
        connection_id_filter = (
            {&#34;connection_id&#34;: self.context.connection_record.connection_id}
            if self.context.connection_record is not None
            else None
        )
        (
            presentation_exchange_record
        ) = await V10PresentationExchange.retrieve_by_tag_filter(
            self.context, {&#34;thread_id&#34;: thread_id}, connection_id_filter
        )

        # Check for bait-and-switch in presented attribute values vs. proposal
        if presentation_exchange_record.presentation_proposal_dict:
            exchange_pres_proposal = PresentationProposal.deserialize(
                presentation_exchange_record.presentation_proposal_dict
            )
            presentation_preview = exchange_pres_proposal.presentation_proposal

            proof_req = presentation_exchange_record.presentation_request
            for (reft, attr_spec) in presentation[&#34;requested_proof&#34;][
                &#34;revealed_attrs&#34;
            ].items():
                name = proof_req[&#34;requested_attributes&#34;][reft][&#34;name&#34;]
                value = attr_spec[&#34;raw&#34;]
                if not presentation_preview.has_attr_spec(
                    cred_def_id=presentation[&#34;identifiers&#34;][
                        attr_spec[&#34;sub_proof_index&#34;]
                    ][&#34;cred_def_id&#34;],
                    name=name,
                    value=value,
                ):
                    raise PresentationManagerError(
                        f&#34;Presentation {name}={value} mismatches proposal value&#34;
                    )

        presentation_exchange_record.presentation = presentation
        presentation_exchange_record.state = (
            V10PresentationExchange.STATE_PRESENTATION_RECEIVED
        )

        await presentation_exchange_record.save(
            self.context, reason=&#34;receive presentation&#34;
        )

        return presentation_exchange_record

    async def verify_presentation(
        self, presentation_exchange_record: V10PresentationExchange
    ):
        &#34;&#34;&#34;
        Verify a presentation.

        Args:
            presentation_exchange_record: presentation exchange record
                with presentation request and presentation to verify

        Returns:
            presentation record, updated

        &#34;&#34;&#34;
        indy_proof_request = presentation_exchange_record.presentation_request
        indy_proof = presentation_exchange_record.presentation

        schema_ids = []
        credential_definition_ids = []

        schemas = {}
        credential_definitions = {}
        rev_reg_defs = {}
        rev_reg_entries = {}

        identifiers = indy_proof[&#34;identifiers&#34;]
        ledger: BaseLedger = await self.context.inject(BaseLedger)
        async with ledger:
            for identifier in identifiers:
                schema_ids.append(identifier[&#34;schema_id&#34;])
                credential_definition_ids.append(identifier[&#34;cred_def_id&#34;])

                # Build schemas for anoncreds
                if identifier[&#34;schema_id&#34;] not in schemas:
                    schemas[identifier[&#34;schema_id&#34;]] = await ledger.get_schema(
                        identifier[&#34;schema_id&#34;]
                    )

                if identifier[&#34;cred_def_id&#34;] not in credential_definitions:
                    credential_definitions[
                        identifier[&#34;cred_def_id&#34;]
                    ] = await ledger.get_credential_definition(
                        identifier[&#34;cred_def_id&#34;]
                    )

                if identifier.get(&#34;rev_reg_id&#34;):
                    if identifier[&#34;rev_reg_id&#34;] not in rev_reg_defs:
                        rev_reg_defs[
                            identifier[&#34;rev_reg_id&#34;]
                        ] = await ledger.get_revoc_reg_def(identifier[&#34;rev_reg_id&#34;])

                    if identifier.get(&#34;timestamp&#34;):
                        rev_reg_entries.setdefault(identifier[&#34;rev_reg_id&#34;], {})

                        if (
                            identifier[&#34;timestamp&#34;]
                            not in rev_reg_entries[identifier[&#34;rev_reg_id&#34;]]
                        ):
                            (
                                found_rev_reg_entry,
                                _found_timestamp,
                            ) = await ledger.get_revoc_reg_entry(
                                identifier[&#34;rev_reg_id&#34;], identifier[&#34;timestamp&#34;]
                            )
                            rev_reg_entries[identifier[&#34;rev_reg_id&#34;]][
                                identifier[&#34;timestamp&#34;]
                            ] = found_rev_reg_entry

        verifier: BaseVerifier = await self.context.inject(BaseVerifier)
        presentation_exchange_record.verified = json.dumps(  # tag: needs string value
            await verifier.verify_presentation(
                indy_proof_request,
                indy_proof,
                schemas,
                credential_definitions,
                rev_reg_defs,
                rev_reg_entries,
            )
        )
        presentation_exchange_record.state = V10PresentationExchange.STATE_VERIFIED

        await presentation_exchange_record.save(
            self.context, reason=&#34;verify presentation&#34;
        )

        await self.send_presentation_ack(presentation_exchange_record)
        return presentation_exchange_record

    async def send_presentation_ack(
        self, presentation_exchange_record: V10PresentationExchange
    ):
        &#34;&#34;&#34;
        Send acknowledgement of presentation receipt.

        Args:
            presentation_exchange_record: presentation exchange record with thread id

        &#34;&#34;&#34;
        responder = await self.context.inject(BaseResponder, required=False)

        if responder:
            presentation_ack_message = PresentationAck()
            presentation_ack_message._thread = {
                &#34;thid&#34;: presentation_exchange_record.thread_id
            }
            presentation_ack_message.assign_trace_decorator(
                self.context.settings, presentation_exchange_record.trace
            )

            await responder.send_reply(
                presentation_ack_message,
                connection_id=presentation_exchange_record.connection_id,
            )
        else:
            LOGGER.warning(
                &#34;Configuration has no BaseResponder: cannot ack presentation on %s&#34;,
                presentation_exchange_record.thread_id,
            )

    async def receive_presentation_ack(self):
        &#34;&#34;&#34;
        Receive a presentation ack, from message in context on manager creation.

        Returns:
            presentation exchange record, retrieved and updated

        &#34;&#34;&#34;
        (
            presentation_exchange_record
        ) = await V10PresentationExchange.retrieve_by_tag_filter(
            self.context,
            {&#34;thread_id&#34;: self.context.message._thread_id},
            {&#34;connection_id&#34;: self.context.connection_record.connection_id},
        )

        presentation_exchange_record.state = (
            V10PresentationExchange.STATE_PRESENTATION_ACKED
        )

        await presentation_exchange_record.save(
            self.context, reason=&#34;receive presentation ack&#34;
        )

        return presentation_exchange_record</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.manager.PresentationManager.context"><code class="name">var <span class="ident">context</span> :Â aries_cloudagent.config.injection_context.InjectionContext</code></dt>
<dd>
<div class="desc"><p>Accessor for the current request context.</p>
<h2 id="returns">Returns</h2>
<p>The injection context for this presentation manager</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def context(self) -&gt; InjectionContext:
    &#34;&#34;&#34;
    Accessor for the current request context.

    Returns:
        The injection context for this presentation manager

    &#34;&#34;&#34;
    return self._context</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.manager.PresentationManager.create_bound_request"><code class="name flex">
<span>async def <span class="ident">create_bound_request</span></span>(<span>self, presentation_exchange_record:Â <a title="mydata_did.patched_protocols.present_proof.v1_0.models.presentation_exchange.V10PresentationExchange" href="models/presentation_exchange.html#mydata_did.patched_protocols.present_proof.v1_0.models.presentation_exchange.V10PresentationExchange">V10PresentationExchange</a>, name:Â strÂ =Â None, version:Â strÂ =Â None, nonce:Â strÂ =Â None, comment:Â strÂ =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a presentation request bound to a proposal.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>presentation_exchange_record</code></strong></dt>
<dd>Presentation exchange record for which
to create presentation request</dd>
<dt><strong><code>name</code></strong></dt>
<dd>name to use in presentation request (None for default)</dd>
<dt><strong><code>version</code></strong></dt>
<dd>version to use in presentation request (None for default)</dd>
<dt><strong><code>nonce</code></strong></dt>
<dd>nonce to use in presentation request (None to generate)</dd>
<dt><strong><code>comment</code></strong></dt>
<dd>Optional human-readable comment pertaining to request creation</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A tuple (updated presentation exchange record, presentation request message)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def create_bound_request(
    self,
    presentation_exchange_record: V10PresentationExchange,
    name: str = None,
    version: str = None,
    nonce: str = None,
    comment: str = None,
):
    &#34;&#34;&#34;
    Create a presentation request bound to a proposal.

    Args:
        presentation_exchange_record: Presentation exchange record for which
            to create presentation request
        name: name to use in presentation request (None for default)
        version: version to use in presentation request (None for default)
        nonce: nonce to use in presentation request (None to generate)
        comment: Optional human-readable comment pertaining to request creation

    Returns:
        A tuple (updated presentation exchange record, presentation request message)

    &#34;&#34;&#34;
    indy_proof_request = await (
        PresentationProposal.deserialize(
            presentation_exchange_record.presentation_proposal_dict
        )
    ).presentation_proposal.indy_proof_request(
        name=name,
        version=version,
        nonce=nonce,
        ledger=await self.context.inject(BaseLedger),
    )
    presentation_request_message = PresentationRequest(
        comment=comment,
        request_presentations_attach=[
            AttachDecorator.from_indy_dict(
                indy_dict=indy_proof_request,
                ident=ATTACH_DECO_IDS[PRESENTATION_REQUEST],
            )
        ],
    )
    presentation_request_message._thread = {
        &#34;thid&#34;: presentation_exchange_record.thread_id
    }
    presentation_request_message.assign_trace_decorator(
        self.context.settings, presentation_exchange_record.trace
    )

    presentation_exchange_record.thread_id = presentation_request_message._thread_id
    presentation_exchange_record.state = V10PresentationExchange.STATE_REQUEST_SENT
    presentation_exchange_record.presentation_request = indy_proof_request
    await presentation_exchange_record.save(
        self.context, reason=&#34;create (bound) presentation request&#34;
    )

    return presentation_exchange_record, presentation_request_message</code></pre>
</details>
</dd>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.manager.PresentationManager.create_exchange_for_proposal"><code class="name flex">
<span>async def <span class="ident">create_exchange_for_proposal</span></span>(<span>self, connection_id:Â str, presentation_proposal_message:Â <a title="mydata_did.patched_protocols.present_proof.v1_0.messages.presentation_proposal.PresentationProposal" href="messages/presentation_proposal.html#mydata_did.patched_protocols.present_proof.v1_0.messages.presentation_proposal.PresentationProposal">PresentationProposal</a>, auto_present:Â boolÂ =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a presentation exchange record for input presentation proposal.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>connection_id</code></strong></dt>
<dd>connection identifier</dd>
<dt><strong><code>presentation_proposal_message</code></strong></dt>
<dd>presentation proposal to serialize
to exchange record</dd>
<dt><strong><code>auto_present</code></strong></dt>
<dd>whether to present proof upon receiving proof request
(default to configuration setting)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Presentation exchange record, created</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def create_exchange_for_proposal(
    self,
    connection_id: str,
    presentation_proposal_message: PresentationProposal,
    auto_present: bool = None,
):
    &#34;&#34;&#34;
    Create a presentation exchange record for input presentation proposal.

    Args:
        connection_id: connection identifier
        presentation_proposal_message: presentation proposal to serialize
            to exchange record
        auto_present: whether to present proof upon receiving proof request
            (default to configuration setting)

    Returns:
        Presentation exchange record, created

    &#34;&#34;&#34;
    presentation_exchange_record = V10PresentationExchange(
        connection_id=connection_id,
        thread_id=presentation_proposal_message._thread_id,
        initiator=V10PresentationExchange.INITIATOR_SELF,
        role=V10PresentationExchange.ROLE_PROVER,
        state=V10PresentationExchange.STATE_PROPOSAL_SENT,
        presentation_proposal_dict=presentation_proposal_message.serialize(),
        auto_present=auto_present,
        trace=(presentation_proposal_message._trace is not None),
    )
    await presentation_exchange_record.save(
        self.context, reason=&#34;create presentation proposal&#34;
    )

    return presentation_exchange_record</code></pre>
</details>
</dd>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.manager.PresentationManager.create_exchange_for_request"><code class="name flex">
<span>async def <span class="ident">create_exchange_for_request</span></span>(<span>self, connection_id:Â str, presentation_request_message:Â <a title="mydata_did.patched_protocols.present_proof.v1_0.messages.presentation_request.PresentationRequest" href="messages/presentation_request.html#mydata_did.patched_protocols.present_proof.v1_0.messages.presentation_request.PresentationRequest">PresentationRequest</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a presentation exchange record for input presentation request.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>connection_id</code></strong></dt>
<dd>connection identifier</dd>
<dt><strong><code>presentation_request_message</code></strong></dt>
<dd>presentation request to use in creating
exchange record, extracting indy proof request and thread id</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Presentation exchange record, updated</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def create_exchange_for_request(
    self, connection_id: str, presentation_request_message: PresentationRequest
):
    &#34;&#34;&#34;
    Create a presentation exchange record for input presentation request.

    Args:
        connection_id: connection identifier
        presentation_request_message: presentation request to use in creating
            exchange record, extracting indy proof request and thread id

    Returns:
        Presentation exchange record, updated

    &#34;&#34;&#34;
    presentation_exchange_record = V10PresentationExchange(
        connection_id=connection_id,
        thread_id=presentation_request_message._thread_id,
        initiator=V10PresentationExchange.INITIATOR_SELF,
        role=V10PresentationExchange.ROLE_VERIFIER,
        state=V10PresentationExchange.STATE_REQUEST_SENT,
        presentation_request=presentation_request_message.indy_proof_request(),
        presentation_request_dict=presentation_request_message.serialize(),
        trace=(presentation_request_message._trace is not None),
    )
    await presentation_exchange_record.save(
        self.context, reason=&#34;create (free) presentation request&#34;
    )

    return presentation_exchange_record</code></pre>
</details>
</dd>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.manager.PresentationManager.create_presentation"><code class="name flex">
<span>async def <span class="ident">create_presentation</span></span>(<span>self, presentation_exchange_record:Â <a title="mydata_did.patched_protocols.present_proof.v1_0.models.presentation_exchange.V10PresentationExchange" href="models/presentation_exchange.html#mydata_did.patched_protocols.present_proof.v1_0.models.presentation_exchange.V10PresentationExchange">V10PresentationExchange</a>, requested_credentials:Â dict, comment:Â strÂ =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a presentation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>presentation_exchange_record</code></strong></dt>
<dd>Record to update</dd>
<dt><strong><code>requested_credentials</code></strong></dt>
<dd>Indy formatted requested_credentials</dd>
<dt><strong><code>comment</code></strong></dt>
<dd>optional human-readable comment</dd>
</dl>
<p>Example <code>requested_credentials</code> format:</p>
<p>::</p>
<pre><code>{
    "self_attested_attributes": {
        "j233ffbc-bd35-49b1-934f-51e083106f6d": "value"
    },
    "requested_attributes": {
        "6253ffbb-bd35-49b3-934f-46e083106f6c": {
            "cred_id": "5bfa40b7-062b-4ae0-a251-a86c87922c0e",
            "revealed": true
        }
    },
    "requested_predicates": {
        "bfc8a97d-60d3-4f21-b998-85eeabe5c8c0": {
            "cred_id": "5bfa40b7-062b-4ae0-a251-a86c87922c0e"
        }
    }
}
</code></pre>
<h2 id="returns">Returns</h2>
<p>A tuple (updated presentation exchange record, presentation message)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def create_presentation(
    self,
    presentation_exchange_record: V10PresentationExchange,
    requested_credentials: dict,
    comment: str = None,
):
    &#34;&#34;&#34;
    Create a presentation.

    Args:
        presentation_exchange_record: Record to update
        requested_credentials: Indy formatted requested_credentials
        comment: optional human-readable comment


    Example `requested_credentials` format:

    ::

        {
            &#34;self_attested_attributes&#34;: {
                &#34;j233ffbc-bd35-49b1-934f-51e083106f6d&#34;: &#34;value&#34;
            },
            &#34;requested_attributes&#34;: {
                &#34;6253ffbb-bd35-49b3-934f-46e083106f6c&#34;: {
                    &#34;cred_id&#34;: &#34;5bfa40b7-062b-4ae0-a251-a86c87922c0e&#34;,
                    &#34;revealed&#34;: true
                }
            },
            &#34;requested_predicates&#34;: {
                &#34;bfc8a97d-60d3-4f21-b998-85eeabe5c8c0&#34;: {
                    &#34;cred_id&#34;: &#34;5bfa40b7-062b-4ae0-a251-a86c87922c0e&#34;
                }
            }
        }

    Returns:
        A tuple (updated presentation exchange record, presentation message)

    &#34;&#34;&#34;
    # Get all credentials for this presentation
    holder: BaseHolder = await self.context.inject(BaseHolder)
    credentials = {}

    # extract credential ids and non_revoked
    requested_referents = {}
    presentation_request = presentation_exchange_record.presentation_request
    attr_creds = requested_credentials.get(&#34;requested_attributes&#34;, {})
    req_attrs = presentation_request.get(&#34;requested_attributes&#34;, {})
    for referent in attr_creds:
        requested_referents[referent] = {&#34;cred_id&#34;: attr_creds[referent][&#34;cred_id&#34;]}
        if referent in req_attrs and &#34;non_revoked&#34; in req_attrs[referent]:
            requested_referents[referent][&#34;non_revoked&#34;] = req_attrs[referent][
                &#34;non_revoked&#34;
            ]

    preds_creds = requested_credentials.get(&#34;requested_predicates&#34;, {})
    req_preds = presentation_request.get(&#34;requested_predicates&#34;, {})
    for referent in preds_creds:
        requested_referents[referent] = {
            &#34;cred_id&#34;: preds_creds[referent][&#34;cred_id&#34;]
        }
        if referent in req_preds and &#34;non_revoked&#34; in req_preds[referent]:
            requested_referents[referent][&#34;non_revoked&#34;] = req_preds[referent][
                &#34;non_revoked&#34;
            ]

    # extract mapping of presentation referents to credential ids
    for referent in requested_referents:
        credential_id = requested_referents[referent][&#34;cred_id&#34;]
        if credential_id not in credentials:
            credentials[credential_id] = json.loads(
                await holder.get_credential(credential_id)
            )

    # Get all schema, credential definition, and revocation registry in use
    ledger: BaseLedger = await self.context.inject(BaseLedger)
    schemas = {}
    credential_definitions = {}
    revocation_registries = {}

    async with ledger:
        for credential in credentials.values():
            schema_id = credential[&#34;schema_id&#34;]
            if schema_id not in schemas:
                schemas[schema_id] = await ledger.get_schema(schema_id)

            credential_definition_id = credential[&#34;cred_def_id&#34;]
            if credential_definition_id not in credential_definitions:
                credential_definitions[
                    credential_definition_id
                ] = await ledger.get_credential_definition(credential_definition_id)

            if credential.get(&#34;rev_reg_id&#34;):
                revocation_registry_id = credential[&#34;rev_reg_id&#34;]
                if revocation_registry_id not in revocation_registries:
                    revocation_registries[
                        revocation_registry_id
                    ] = RevocationRegistry.from_definition(
                        await ledger.get_revoc_reg_def(revocation_registry_id), True
                    )

    # Get delta with non-revocation interval defined in &#34;non_revoked&#34;
    # of the presentation request or attributes
    epoch_now = int(time.time())

    non_revoc_interval = {&#34;from&#34;: 0, &#34;to&#34;: epoch_now}
    non_revoc_interval.update(
        presentation_exchange_record.presentation_request.get(&#34;non_revoked&#34;) or {}
    )

    revoc_reg_deltas = {}
    async with ledger:
        for precis in requested_referents.values():  # cred_id, non-revoc interval
            credential_id = precis[&#34;cred_id&#34;]
            if not credentials[credential_id].get(&#34;rev_reg_id&#34;):
                continue
            if &#34;timestamp&#34; in precis:
                continue
            rev_reg_id = credentials[credential_id][&#34;rev_reg_id&#34;]
            referent_non_revoc_interval = precis.get(
                &#34;non_revoked&#34;, non_revoc_interval
            )

            if referent_non_revoc_interval:
                key = (
                    f&#34;{rev_reg_id}_{referent_non_revoc_interval.get(&#39;from&#39;, 0)}_&#34;
                    f&#34;{referent_non_revoc_interval.get(&#39;to&#39;, epoch_now)}&#34;
                )
                if key not in revoc_reg_deltas:
                    (delta, delta_timestamp) = await ledger.get_revoc_reg_delta(
                        rev_reg_id,
                        referent_non_revoc_interval.get(&#34;from&#34;, 0),
                        referent_non_revoc_interval.get(&#34;to&#34;, epoch_now),
                    )
                    revoc_reg_deltas[key] = (
                        rev_reg_id,
                        credential_id,
                        delta,
                        delta_timestamp,
                    )
                for stamp_me in requested_referents.values():
                    # often one cred satisfies many requested attrs/preds
                    if stamp_me[&#34;cred_id&#34;] == credential_id:
                        stamp_me[&#34;timestamp&#34;] = revoc_reg_deltas[key][3]

    # Get revocation states to prove non-revoked
    revocation_states = {}
    for (
        rev_reg_id,
        credential_id,
        delta,
        delta_timestamp,
    ) in revoc_reg_deltas.values():
        if rev_reg_id not in revocation_states:
            revocation_states[rev_reg_id] = {}

        rev_reg = revocation_registries[rev_reg_id]
        tails_local_path = await rev_reg.get_or_fetch_local_tails_path()

        try:
            revocation_states[rev_reg_id][delta_timestamp] = json.loads(
                await holder.create_revocation_state(
                    credentials[credential_id][&#34;cred_rev_id&#34;],
                    rev_reg.reg_def,
                    delta,
                    delta_timestamp,
                    tails_local_path,
                )
            )
        except HolderError as e:
            LOGGER.error(
                f&#34;Failed to create revocation state: {e.error_code}, {e.message}&#34;
            )
            raise e

    for (referent, precis) in requested_referents.items():
        if &#34;timestamp&#34; not in precis:
            continue
        if referent in requested_credentials[&#34;requested_attributes&#34;]:
            requested_credentials[&#34;requested_attributes&#34;][referent][
                &#34;timestamp&#34;
            ] = precis[&#34;timestamp&#34;]
        if referent in requested_credentials[&#34;requested_predicates&#34;]:
            requested_credentials[&#34;requested_predicates&#34;][referent][
                &#34;timestamp&#34;
            ] = precis[&#34;timestamp&#34;]

    indy_proof_json = await holder.create_presentation(
        presentation_exchange_record.presentation_request,
        requested_credentials,
        schemas,
        credential_definitions,
        revocation_states,
    )
    indy_proof = json.loads(indy_proof_json)

    presentation_message = Presentation(
        comment=comment,
        presentations_attach=[
            AttachDecorator.from_indy_dict(
                indy_dict=indy_proof, ident=ATTACH_DECO_IDS[PRESENTATION]
            )
        ],
    )

    presentation_message._thread = {&#34;thid&#34;: presentation_exchange_record.thread_id}
    presentation_message.assign_trace_decorator(
        self.context.settings, presentation_exchange_record.trace
    )

    # save presentation exchange state
    presentation_exchange_record.state = (
        V10PresentationExchange.STATE_PRESENTATION_SENT
    )
    presentation_exchange_record.presentation = indy_proof
    await presentation_exchange_record.save(
        self.context, reason=&#34;create presentation&#34;
    )

    return presentation_exchange_record, presentation_message</code></pre>
</details>
</dd>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.manager.PresentationManager.receive_presentation"><code class="name flex">
<span>async def <span class="ident">receive_presentation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Receive a presentation, from message in context on manager creation.</p>
<h2 id="returns">Returns</h2>
<p>presentation exchange record, retrieved and updated</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def receive_presentation(self):
    &#34;&#34;&#34;
    Receive a presentation, from message in context on manager creation.

    Returns:
        presentation exchange record, retrieved and updated

    &#34;&#34;&#34;
    presentation = self.context.message.indy_proof()

    thread_id = self.context.message._thread_id
    connection_id_filter = (
        {&#34;connection_id&#34;: self.context.connection_record.connection_id}
        if self.context.connection_record is not None
        else None
    )
    (
        presentation_exchange_record
    ) = await V10PresentationExchange.retrieve_by_tag_filter(
        self.context, {&#34;thread_id&#34;: thread_id}, connection_id_filter
    )

    # Check for bait-and-switch in presented attribute values vs. proposal
    if presentation_exchange_record.presentation_proposal_dict:
        exchange_pres_proposal = PresentationProposal.deserialize(
            presentation_exchange_record.presentation_proposal_dict
        )
        presentation_preview = exchange_pres_proposal.presentation_proposal

        proof_req = presentation_exchange_record.presentation_request
        for (reft, attr_spec) in presentation[&#34;requested_proof&#34;][
            &#34;revealed_attrs&#34;
        ].items():
            name = proof_req[&#34;requested_attributes&#34;][reft][&#34;name&#34;]
            value = attr_spec[&#34;raw&#34;]
            if not presentation_preview.has_attr_spec(
                cred_def_id=presentation[&#34;identifiers&#34;][
                    attr_spec[&#34;sub_proof_index&#34;]
                ][&#34;cred_def_id&#34;],
                name=name,
                value=value,
            ):
                raise PresentationManagerError(
                    f&#34;Presentation {name}={value} mismatches proposal value&#34;
                )

    presentation_exchange_record.presentation = presentation
    presentation_exchange_record.state = (
        V10PresentationExchange.STATE_PRESENTATION_RECEIVED
    )

    await presentation_exchange_record.save(
        self.context, reason=&#34;receive presentation&#34;
    )

    return presentation_exchange_record</code></pre>
</details>
</dd>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.manager.PresentationManager.receive_presentation_ack"><code class="name flex">
<span>async def <span class="ident">receive_presentation_ack</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Receive a presentation ack, from message in context on manager creation.</p>
<h2 id="returns">Returns</h2>
<p>presentation exchange record, retrieved and updated</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def receive_presentation_ack(self):
    &#34;&#34;&#34;
    Receive a presentation ack, from message in context on manager creation.

    Returns:
        presentation exchange record, retrieved and updated

    &#34;&#34;&#34;
    (
        presentation_exchange_record
    ) = await V10PresentationExchange.retrieve_by_tag_filter(
        self.context,
        {&#34;thread_id&#34;: self.context.message._thread_id},
        {&#34;connection_id&#34;: self.context.connection_record.connection_id},
    )

    presentation_exchange_record.state = (
        V10PresentationExchange.STATE_PRESENTATION_ACKED
    )

    await presentation_exchange_record.save(
        self.context, reason=&#34;receive presentation ack&#34;
    )

    return presentation_exchange_record</code></pre>
</details>
</dd>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.manager.PresentationManager.receive_proposal"><code class="name flex">
<span>async def <span class="ident">receive_proposal</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Receive a presentation proposal from message in context on manager creation.</p>
<h2 id="returns">Returns</h2>
<p>Presentation exchange record, created</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def receive_proposal(self):
    &#34;&#34;&#34;
    Receive a presentation proposal from message in context on manager creation.

    Returns:
        Presentation exchange record, created

    &#34;&#34;&#34;
    presentation_proposal_message = self.context.message
    presentation_exchange_record = V10PresentationExchange(
        connection_id=self.context.connection_record.connection_id,
        thread_id=presentation_proposal_message._thread_id,
        initiator=V10PresentationExchange.INITIATOR_EXTERNAL,
        role=V10PresentationExchange.ROLE_VERIFIER,
        state=V10PresentationExchange.STATE_PROPOSAL_RECEIVED,
        presentation_proposal_dict=presentation_proposal_message.serialize(),
        trace=(presentation_proposal_message._trace is not None),
    )
    await presentation_exchange_record.save(
        self.context, reason=&#34;receive presentation request&#34;
    )

    return presentation_exchange_record</code></pre>
</details>
</dd>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.manager.PresentationManager.receive_request"><code class="name flex">
<span>async def <span class="ident">receive_request</span></span>(<span>self, presentation_exchange_record:Â <a title="mydata_did.patched_protocols.present_proof.v1_0.models.presentation_exchange.V10PresentationExchange" href="models/presentation_exchange.html#mydata_did.patched_protocols.present_proof.v1_0.models.presentation_exchange.V10PresentationExchange">V10PresentationExchange</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Receive a presentation request.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>presentation_exchange_record</code></strong></dt>
<dd>presentation exchange record with
request to receive</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The presentation_exchange_record, updated</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def receive_request(
    self, presentation_exchange_record: V10PresentationExchange
):
    &#34;&#34;&#34;
    Receive a presentation request.

    Args:
        presentation_exchange_record: presentation exchange record with
            request to receive

    Returns:
        The presentation_exchange_record, updated

    &#34;&#34;&#34;
    presentation_exchange_record.state = (
        V10PresentationExchange.STATE_REQUEST_RECEIVED
    )
    await presentation_exchange_record.save(
        self.context, reason=&#34;receive presentation request&#34;
    )

    return presentation_exchange_record</code></pre>
</details>
</dd>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.manager.PresentationManager.send_presentation_ack"><code class="name flex">
<span>async def <span class="ident">send_presentation_ack</span></span>(<span>self, presentation_exchange_record:Â <a title="mydata_did.patched_protocols.present_proof.v1_0.models.presentation_exchange.V10PresentationExchange" href="models/presentation_exchange.html#mydata_did.patched_protocols.present_proof.v1_0.models.presentation_exchange.V10PresentationExchange">V10PresentationExchange</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Send acknowledgement of presentation receipt.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>presentation_exchange_record</code></strong></dt>
<dd>presentation exchange record with thread id</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def send_presentation_ack(
    self, presentation_exchange_record: V10PresentationExchange
):
    &#34;&#34;&#34;
    Send acknowledgement of presentation receipt.

    Args:
        presentation_exchange_record: presentation exchange record with thread id

    &#34;&#34;&#34;
    responder = await self.context.inject(BaseResponder, required=False)

    if responder:
        presentation_ack_message = PresentationAck()
        presentation_ack_message._thread = {
            &#34;thid&#34;: presentation_exchange_record.thread_id
        }
        presentation_ack_message.assign_trace_decorator(
            self.context.settings, presentation_exchange_record.trace
        )

        await responder.send_reply(
            presentation_ack_message,
            connection_id=presentation_exchange_record.connection_id,
        )
    else:
        LOGGER.warning(
            &#34;Configuration has no BaseResponder: cannot ack presentation on %s&#34;,
            presentation_exchange_record.thread_id,
        )</code></pre>
</details>
</dd>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.manager.PresentationManager.verify_presentation"><code class="name flex">
<span>async def <span class="ident">verify_presentation</span></span>(<span>self, presentation_exchange_record:Â <a title="mydata_did.patched_protocols.present_proof.v1_0.models.presentation_exchange.V10PresentationExchange" href="models/presentation_exchange.html#mydata_did.patched_protocols.present_proof.v1_0.models.presentation_exchange.V10PresentationExchange">V10PresentationExchange</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Verify a presentation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>presentation_exchange_record</code></strong></dt>
<dd>presentation exchange record
with presentation request and presentation to verify</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>presentation record, updated</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def verify_presentation(
    self, presentation_exchange_record: V10PresentationExchange
):
    &#34;&#34;&#34;
    Verify a presentation.

    Args:
        presentation_exchange_record: presentation exchange record
            with presentation request and presentation to verify

    Returns:
        presentation record, updated

    &#34;&#34;&#34;
    indy_proof_request = presentation_exchange_record.presentation_request
    indy_proof = presentation_exchange_record.presentation

    schema_ids = []
    credential_definition_ids = []

    schemas = {}
    credential_definitions = {}
    rev_reg_defs = {}
    rev_reg_entries = {}

    identifiers = indy_proof[&#34;identifiers&#34;]
    ledger: BaseLedger = await self.context.inject(BaseLedger)
    async with ledger:
        for identifier in identifiers:
            schema_ids.append(identifier[&#34;schema_id&#34;])
            credential_definition_ids.append(identifier[&#34;cred_def_id&#34;])

            # Build schemas for anoncreds
            if identifier[&#34;schema_id&#34;] not in schemas:
                schemas[identifier[&#34;schema_id&#34;]] = await ledger.get_schema(
                    identifier[&#34;schema_id&#34;]
                )

            if identifier[&#34;cred_def_id&#34;] not in credential_definitions:
                credential_definitions[
                    identifier[&#34;cred_def_id&#34;]
                ] = await ledger.get_credential_definition(
                    identifier[&#34;cred_def_id&#34;]
                )

            if identifier.get(&#34;rev_reg_id&#34;):
                if identifier[&#34;rev_reg_id&#34;] not in rev_reg_defs:
                    rev_reg_defs[
                        identifier[&#34;rev_reg_id&#34;]
                    ] = await ledger.get_revoc_reg_def(identifier[&#34;rev_reg_id&#34;])

                if identifier.get(&#34;timestamp&#34;):
                    rev_reg_entries.setdefault(identifier[&#34;rev_reg_id&#34;], {})

                    if (
                        identifier[&#34;timestamp&#34;]
                        not in rev_reg_entries[identifier[&#34;rev_reg_id&#34;]]
                    ):
                        (
                            found_rev_reg_entry,
                            _found_timestamp,
                        ) = await ledger.get_revoc_reg_entry(
                            identifier[&#34;rev_reg_id&#34;], identifier[&#34;timestamp&#34;]
                        )
                        rev_reg_entries[identifier[&#34;rev_reg_id&#34;]][
                            identifier[&#34;timestamp&#34;]
                        ] = found_rev_reg_entry

    verifier: BaseVerifier = await self.context.inject(BaseVerifier)
    presentation_exchange_record.verified = json.dumps(  # tag: needs string value
        await verifier.verify_presentation(
            indy_proof_request,
            indy_proof,
            schemas,
            credential_definitions,
            rev_reg_defs,
            rev_reg_entries,
        )
    )
    presentation_exchange_record.state = V10PresentationExchange.STATE_VERIFIED

    await presentation_exchange_record.save(
        self.context, reason=&#34;verify presentation&#34;
    )

    await self.send_presentation_ack(presentation_exchange_record)
    return presentation_exchange_record</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mydata_did.patched_protocols.present_proof.v1_0.manager.PresentationManagerError"><code class="flex name class">
<span>class <span class="ident">PresentationManagerError</span></span>
<span>(</span><span>*args, error_code:Â strÂ =Â None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Presentation error.</p>
<p>Initialize a BaseError instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PresentationManagerError(BaseError):
    &#34;&#34;&#34;Presentation error.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>aries_cloudagent.core.error.BaseError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="mydata_did.patched_protocols.present_proof.v1_0" href="index.html">mydata_did.patched_protocols.present_proof.v1_0</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="mydata_did.patched_protocols.present_proof.v1_0.manager.PresentationManager" href="#mydata_did.patched_protocols.present_proof.v1_0.manager.PresentationManager">PresentationManager</a></code></h4>
<ul class="">
<li><code><a title="mydata_did.patched_protocols.present_proof.v1_0.manager.PresentationManager.context" href="#mydata_did.patched_protocols.present_proof.v1_0.manager.PresentationManager.context">context</a></code></li>
<li><code><a title="mydata_did.patched_protocols.present_proof.v1_0.manager.PresentationManager.create_bound_request" href="#mydata_did.patched_protocols.present_proof.v1_0.manager.PresentationManager.create_bound_request">create_bound_request</a></code></li>
<li><code><a title="mydata_did.patched_protocols.present_proof.v1_0.manager.PresentationManager.create_exchange_for_proposal" href="#mydata_did.patched_protocols.present_proof.v1_0.manager.PresentationManager.create_exchange_for_proposal">create_exchange_for_proposal</a></code></li>
<li><code><a title="mydata_did.patched_protocols.present_proof.v1_0.manager.PresentationManager.create_exchange_for_request" href="#mydata_did.patched_protocols.present_proof.v1_0.manager.PresentationManager.create_exchange_for_request">create_exchange_for_request</a></code></li>
<li><code><a title="mydata_did.patched_protocols.present_proof.v1_0.manager.PresentationManager.create_presentation" href="#mydata_did.patched_protocols.present_proof.v1_0.manager.PresentationManager.create_presentation">create_presentation</a></code></li>
<li><code><a title="mydata_did.patched_protocols.present_proof.v1_0.manager.PresentationManager.receive_presentation" href="#mydata_did.patched_protocols.present_proof.v1_0.manager.PresentationManager.receive_presentation">receive_presentation</a></code></li>
<li><code><a title="mydata_did.patched_protocols.present_proof.v1_0.manager.PresentationManager.receive_presentation_ack" href="#mydata_did.patched_protocols.present_proof.v1_0.manager.PresentationManager.receive_presentation_ack">receive_presentation_ack</a></code></li>
<li><code><a title="mydata_did.patched_protocols.present_proof.v1_0.manager.PresentationManager.receive_proposal" href="#mydata_did.patched_protocols.present_proof.v1_0.manager.PresentationManager.receive_proposal">receive_proposal</a></code></li>
<li><code><a title="mydata_did.patched_protocols.present_proof.v1_0.manager.PresentationManager.receive_request" href="#mydata_did.patched_protocols.present_proof.v1_0.manager.PresentationManager.receive_request">receive_request</a></code></li>
<li><code><a title="mydata_did.patched_protocols.present_proof.v1_0.manager.PresentationManager.send_presentation_ack" href="#mydata_did.patched_protocols.present_proof.v1_0.manager.PresentationManager.send_presentation_ack">send_presentation_ack</a></code></li>
<li><code><a title="mydata_did.patched_protocols.present_proof.v1_0.manager.PresentationManager.verify_presentation" href="#mydata_did.patched_protocols.present_proof.v1_0.manager.PresentationManager.verify_presentation">verify_presentation</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mydata_did.patched_protocols.present_proof.v1_0.manager.PresentationManagerError" href="#mydata_did.patched_protocols.present_proof.v1_0.manager.PresentationManagerError">PresentationManagerError</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>