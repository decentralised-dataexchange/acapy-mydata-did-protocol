<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>mydata_did.v1_0.utils.wallet.crypto API documentation</title>
<meta name="description" content="Cryptography functions used by BasicWallet." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>mydata_did.v1_0.utils.wallet.crypto</code></h1>
</header>
<section id="section-intro">
<p>Cryptography functions used by BasicWallet.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Cryptography functions used by BasicWallet.&#34;&#34;&#34;

from collections import OrderedDict
from typing import Callable, Optional, Sequence, Tuple, Union, List

import nacl.bindings
import nacl.exceptions
import nacl.utils

from marshmallow import ValidationError

from ..jwe import JweRecipient, b64url, JweEnvelope, from_b64url
from .error import WalletError
from .util import bytes_to_b58, b64_to_bytes, b58_to_bytes, random_seed
from .key_type import KeyType

def create_keypair(key_type: KeyType, seed: bytes = None) -&gt; Tuple[bytes, bytes]:
    &#34;&#34;&#34;
    Create a public and private keypair from a seed value.

    Args:
        key_type: The type of key to generate
        seed: Seed for keypair

    Raises:
        WalletError: If the key type is not supported

    Returns:
        A tuple of (public key, secret key)

    &#34;&#34;&#34;
    if key_type == KeyType.ED25519:
        return create_ed25519_keypair(seed)
    else:
        raise WalletError(f&#34;Unsupported key type: {key_type.key_type}&#34;)


def create_ed25519_keypair(seed: bytes = None) -&gt; Tuple[bytes, bytes]:
    &#34;&#34;&#34;
    Create a public and private ed25519 keypair from a seed value.

    Args:
        seed: Seed for keypair

    Returns:
        A tuple of (public key, secret key)

    &#34;&#34;&#34;
    if not seed:
        seed = random_seed()
    pk, sk = nacl.bindings.crypto_sign_seed_keypair(seed)
    return pk, sk


def seed_to_did(seed: str) -&gt; str:
    &#34;&#34;&#34;
    Derive a DID from a seed value.

    Args:
        seed: The seed to derive

    Returns:
        The DID derived from the seed

    &#34;&#34;&#34;
    seed = validate_seed(seed)
    verkey, _ = create_ed25519_keypair(seed)
    did = bytes_to_b58(verkey[:16])
    return did


def sign_pk_from_sk(secret: bytes) -&gt; bytes:
    &#34;&#34;&#34;Extract the verkey from a secret signing key.&#34;&#34;&#34;
    seed_len = nacl.bindings.crypto_sign_SEEDBYTES
    return secret[seed_len:]


def validate_seed(seed: Union[str, bytes]) -&gt; bytes:
    &#34;&#34;&#34;
    Convert a seed parameter to standard format and check length.

    Args:
        seed: The seed to validate

    Returns:
        The validated and encoded seed

    &#34;&#34;&#34;
    if not seed:
        return None
    if isinstance(seed, str):
        if &#34;=&#34; in seed:
            seed = b64_to_bytes(seed)
        else:
            seed = seed.encode(&#34;ascii&#34;)
    if not isinstance(seed, bytes):
        raise WalletError(&#34;Seed value is not a string or bytes&#34;)
    if len(seed) != 32:
        raise WalletError(&#34;Seed value must be 32 bytes in length&#34;)
    return seed


def sign_message(
    message: Union[List[bytes], bytes], secret: bytes, key_type: KeyType
) -&gt; bytes:
    &#34;&#34;&#34;
    Sign message(s) using a private signing key.

    Args:
        message: The message(s) to sign
        secret: The private signing key
        key_type: The key type to derive the signature algorithm from

    Returns:
        bytes: The signature

    &#34;&#34;&#34;
    # Make messages list if not already for easier checking going forward
    messages = message if isinstance(message, list) else [message]

    if key_type == KeyType.ED25519:
        if len(messages) &gt; 1:
            raise WalletError(&#34;ed25519 can only sign a single message&#34;)

        return sign_message_ed25519(
            message=messages[0],
            secret=secret,
        )
    else:
        raise WalletError(f&#34;Unsupported key type: {key_type.key_type}&#34;)


def sign_message_ed25519(message: bytes, secret: bytes) -&gt; bytes:
    &#34;&#34;&#34;Sign message using a ed25519 private signing key.

    Args:
        messages (bytes): The message to sign
        secret (bytes): The private signing key

    Returns:
        bytes: The signature

    &#34;&#34;&#34;
    result = nacl.bindings.crypto_sign(message, secret)
    sig = result[: nacl.bindings.crypto_sign_BYTES]
    return sig


def verify_signed_message(
    message: Union[List[bytes], bytes],
    signature: bytes,
    verkey: bytes,
    key_type: KeyType,
) -&gt; bool:
    &#34;&#34;&#34;
    Verify a signed message according to a public verification key.

    Args:
        message: The message(s) to verify
        signature: The signature to verify
        verkey: The verkey to use in verification
        key_type: The key type to derive the signature verification algorithm from

    Returns:
        True if verified, else False

    &#34;&#34;&#34;
    # Make messages list if not already for easier checking going forward
    messages = message if isinstance(message, list) else [message]

    if key_type == KeyType.ED25519:
        if len(messages) &gt; 1:
            raise WalletError(&#34;ed25519 can only verify a single message&#34;)

        return verify_signed_message_ed25519(
            message=messages[0], signature=signature, verkey=verkey
        )
    else:
        raise WalletError(f&#34;Unsupported key type: {key_type.key_type}&#34;)


def verify_signed_message_ed25519(
    message: bytes, signature: bytes, verkey: bytes
) -&gt; bool:
    &#34;&#34;&#34;
    Verify an ed25519 signed message according to a public verification key.

    Args:
        message: The message to verify
        signature: The signature to verify
        verkey: The verkey to use in verification

    Returns:
        True if verified, else False

    &#34;&#34;&#34;
    try:
        nacl.bindings.crypto_sign_open(signature + message, verkey)
    except nacl.exceptions.BadSignatureError:
        return False
    return True


def add_pack_recipients(
    wrapper: JweEnvelope,
    cek: bytes,
    to_verkeys: Sequence[bytes],
    from_secret: bytes = None,
):
    &#34;&#34;&#34;
    Assemble the recipients block of a packed message.

    Args:
        wrapper: The envelope to add recipients to
        cek: The content encryption key
        to_verkeys: Verkeys of recipients
        from_secret: Secret to use for signing keys

    Returns:
        A tuple of (json result, key)

    &#34;&#34;&#34;
    for target_vk in to_verkeys:
        target_pk = nacl.bindings.crypto_sign_ed25519_pk_to_curve25519(target_vk)
        if from_secret:
            sender_pk = sign_pk_from_sk(from_secret)
            sender_vk = bytes_to_b58(sender_pk).encode(&#34;utf-8&#34;)
            enc_sender = nacl.bindings.crypto_box_seal(sender_vk, target_pk)
            sk = nacl.bindings.crypto_sign_ed25519_sk_to_curve25519(from_secret)

            nonce = nacl.utils.random(nacl.bindings.crypto_box_NONCEBYTES)
            enc_cek = nacl.bindings.crypto_box(cek, nonce, target_pk, sk)
            wrapper.add_recipient(
                JweRecipient(
                    encrypted_key=enc_cek,
                    header=OrderedDict(
                        [
                            (&#34;kid&#34;, bytes_to_b58(target_vk)),
                            (&#34;sender&#34;, b64url(enc_sender)),
                            (&#34;iv&#34;, b64url(nonce)),
                        ]
                    ),
                )
            )
        else:
            enc_sender = None
            nonce = None
            enc_cek = nacl.bindings.crypto_box_seal(cek, target_pk)
            wrapper.add_recipient(
                JweRecipient(
                    encrypted_key=enc_cek, header={&#34;kid&#34;: bytes_to_b58(target_vk)}
                )
            )


def ed25519_pk_to_curve25519(public_key: bytes) -&gt; bytes:
    &#34;&#34;&#34;Covert a public Ed25519 key to a public Curve25519 key as bytes.&#34;&#34;&#34;
    return nacl.bindings.crypto_sign_ed25519_pk_to_curve25519(public_key)


def encrypt_plaintext(
    message: str, add_data: bytes, key: bytes
) -&gt; Tuple[bytes, bytes, bytes]:
    &#34;&#34;&#34;
    Encrypt the payload of a packed message.

    Args:
        message: Message to encrypt
        add_data:
        key: Key used for encryption

    Returns:
        A tuple of (ciphertext, nonce, tag)

    &#34;&#34;&#34;
    nonce = nacl.utils.random(nacl.bindings.crypto_aead_chacha20poly1305_ietf_NPUBBYTES)
    message_bin = message.encode(&#34;utf-8&#34;)
    output = nacl.bindings.crypto_aead_chacha20poly1305_ietf_encrypt(
        message_bin, add_data, nonce, key
    )
    mlen = len(message)
    ciphertext = output[:mlen]
    tag = output[mlen:]
    return ciphertext, nonce, tag


def decrypt_plaintext(
    ciphertext: bytes, recips_bin: bytes, nonce: bytes, key: bytes
) -&gt; str:
    &#34;&#34;&#34;
    Decrypt the payload of a packed message.

    Args:
        ciphertext:
        recips_bin:
        nonce:
        key:

    Returns:
        The decrypted string

    &#34;&#34;&#34;
    output = nacl.bindings.crypto_aead_chacha20poly1305_ietf_decrypt(
        ciphertext, recips_bin, nonce, key
    )
    return output.decode(&#34;utf-8&#34;)


def encode_pack_message(
    message: str, to_verkeys: Sequence[bytes], from_secret: bytes = None
) -&gt; bytes:
    &#34;&#34;&#34;
    Assemble a packed message for a set of recipients, optionally including the sender.

    Args:
        message: The message to pack
        to_verkeys: The verkeys to pack the message for
        from_secret: The sender secret

    Returns:
        The encoded message

    &#34;&#34;&#34;
    wrapper = JweEnvelope()
    cek = nacl.bindings.crypto_secretstream_xchacha20poly1305_keygen()
    add_pack_recipients(wrapper, cek, to_verkeys, from_secret)
    wrapper.set_protected(
        OrderedDict(
            [
                (&#34;enc&#34;, &#34;xchacha20poly1305_ietf&#34;),
                (&#34;typ&#34;, &#34;JWM/1.0&#34;),
                (&#34;alg&#34;, &#34;Authcrypt&#34; if from_secret else &#34;Anoncrypt&#34;),
            ]
        ),
        auto_flatten=False,
    )
    ciphertext, nonce, tag = encrypt_plaintext(message, wrapper.protected_bytes, cek)
    wrapper.set_payload(ciphertext, nonce, tag)
    return wrapper.to_json().encode(&#34;utf-8&#34;)


def decode_pack_message(
    enc_message: bytes, find_key: Callable
) -&gt; Tuple[str, Optional[str], str]:
    &#34;&#34;&#34;
    Decode a packed message.

    Disassemble and unencrypt a packed message, returning the message content,
    verification key of the sender (if available), and verification key of the
    recipient.

    Args:
        enc_message: The encrypted message
        find_key: Function to retrieve private key

    Returns:
        A tuple of (message, sender_vk, recip_vk)

    Raises:
        ValueError: If the packed message is invalid
        ValueError: If the packed message reipients are invalid
        ValueError: If the pack algorithm is unsupported
        ValueError: If the sender&#39;s public key was not provided

    &#34;&#34;&#34;
    wrapper, recips, is_authcrypt = decode_pack_message_outer(enc_message)
    payload_key, sender_vk = None, None
    for recip_vk in recips:
        recip_secret = find_key(recip_vk)
        if recip_secret:
            payload_key, sender_vk = extract_payload_key(recips[recip_vk], recip_secret)
            break

    if not payload_key:
        raise ValueError(
            &#34;No corresponding recipient key found in {}&#34;.format(tuple(recips))
        )
    if not sender_vk and is_authcrypt:
        raise ValueError(&#34;Sender public key not provided for Authcrypt message&#34;)

    message = decode_pack_message_payload(wrapper, payload_key)
    return message, sender_vk, recip_vk


def decode_pack_message_outer(enc_message: bytes) -&gt; Tuple[dict, dict, bool]:
    &#34;&#34;&#34;
    Decode the outer wrapper of a packed message and extract the recipients.

    Args:
        enc_message: The encrypted message

    Returns: a tuple of the decoded wrapper, recipients, and authcrypt flag

    &#34;&#34;&#34;
    try:
        wrapper = JweEnvelope.from_json(enc_message)
    except ValidationError:
        raise ValueError(&#34;Invalid packed message&#34;)

    alg = wrapper.protected.get(&#34;alg&#34;)
    is_authcrypt = alg == &#34;Authcrypt&#34;
    if not is_authcrypt and alg != &#34;Anoncrypt&#34;:
        raise ValueError(&#34;Unsupported pack algorithm: {}&#34;.format(alg))

    recips = extract_pack_recipients(wrapper.recipients())
    return wrapper, recips, is_authcrypt


def decode_pack_message_payload(wrapper: JweEnvelope, payload_key: bytes) -&gt; str:
    &#34;&#34;&#34;
    Decode the payload of a packed message once the CEK is known.

    Args:
        wrapper: The decoded message wrapper
        payload_key: The decrypted payload key

    &#34;&#34;&#34;
    payload_bin = wrapper.ciphertext + wrapper.tag
    message = decrypt_plaintext(
        payload_bin, wrapper.protected_bytes, wrapper.iv, payload_key
    )
    return message


def extract_pack_recipients(recipients: Sequence[JweRecipient]) -&gt; dict:
    &#34;&#34;&#34;
    Extract the pack message recipients into a dict indexed by verkey.

    Args:
        recipients: Recipients to locate

    Raises:
        ValueError: If the recipients block is mal-formatted

    &#34;&#34;&#34;
    result = {}
    for recip in recipients:
        recip_vk_b58 = recip.header.get(&#34;kid&#34;)
        if not recip_vk_b58:
            raise ValueError(&#34;Blank recipient key&#34;)
        if recip_vk_b58 in result:
            raise ValueError(&#34;Duplicate recipient key&#34;)

        sender_b64 = recip.header.get(&#34;sender&#34;)
        enc_sender = from_b64url(sender_b64) if sender_b64 else None

        nonce_b64 = recip.header.get(&#34;iv&#34;)
        if sender_b64 and not nonce_b64:
            raise ValueError(&#34;Missing iv&#34;)
        elif not sender_b64 and nonce_b64:
            raise ValueError(&#34;Unexpected iv&#34;)
        nonce = from_b64url(nonce_b64) if nonce_b64 else None

        result[recip_vk_b58] = {
            &#34;sender&#34;: enc_sender,
            &#34;nonce&#34;: nonce,
            &#34;key&#34;: recip.encrypted_key,
        }
    return result


def extract_payload_key(sender_cek: dict, recip_secret: bytes) -&gt; Tuple[bytes, str]:
    &#34;&#34;&#34;
    Extract the payload key from pack recipient details.

    Returns: A tuple of the CEK and sender verkey
    &#34;&#34;&#34;
    recip_vk = sign_pk_from_sk(recip_secret)
    recip_pk = nacl.bindings.crypto_sign_ed25519_pk_to_curve25519(recip_vk)
    recip_sk = nacl.bindings.crypto_sign_ed25519_sk_to_curve25519(recip_secret)

    if sender_cek[&#34;nonce&#34;] and sender_cek[&#34;sender&#34;]:
        sender_vk_bin = nacl.bindings.crypto_box_seal_open(
            sender_cek[&#34;sender&#34;], recip_pk, recip_sk
        )
        sender_vk = sender_vk_bin.decode(&#34;utf-8&#34;)
        sender_pk = nacl.bindings.crypto_sign_ed25519_pk_to_curve25519(
            b58_to_bytes(sender_vk_bin)
        )
        cek = nacl.bindings.crypto_box_open(
            sender_cek[&#34;key&#34;], sender_cek[&#34;nonce&#34;], sender_pk, recip_sk
        )
    else:
        sender_vk = None
        cek = nacl.bindings.crypto_box_seal_open(sender_cek[&#34;key&#34;], recip_pk, recip_sk)
    return cek, sender_vk</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="mydata_did.v1_0.utils.wallet.crypto.add_pack_recipients"><code class="name flex">
<span>def <span class="ident">add_pack_recipients</span></span>(<span>wrapper: <a title="mydata_did.v1_0.utils.jwe.JweEnvelope" href="../jwe.html#mydata_did.v1_0.utils.jwe.JweEnvelope">JweEnvelope</a>, cek: bytes, to_verkeys: Sequence[bytes], from_secret: bytes = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Assemble the recipients block of a packed message.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>wrapper</code></strong></dt>
<dd>The envelope to add recipients to</dd>
<dt><strong><code>cek</code></strong></dt>
<dd>The content encryption key</dd>
<dt><strong><code>to_verkeys</code></strong></dt>
<dd>Verkeys of recipients</dd>
<dt><strong><code>from_secret</code></strong></dt>
<dd>Secret to use for signing keys</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A tuple of (json result, key)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_pack_recipients(
    wrapper: JweEnvelope,
    cek: bytes,
    to_verkeys: Sequence[bytes],
    from_secret: bytes = None,
):
    &#34;&#34;&#34;
    Assemble the recipients block of a packed message.

    Args:
        wrapper: The envelope to add recipients to
        cek: The content encryption key
        to_verkeys: Verkeys of recipients
        from_secret: Secret to use for signing keys

    Returns:
        A tuple of (json result, key)

    &#34;&#34;&#34;
    for target_vk in to_verkeys:
        target_pk = nacl.bindings.crypto_sign_ed25519_pk_to_curve25519(target_vk)
        if from_secret:
            sender_pk = sign_pk_from_sk(from_secret)
            sender_vk = bytes_to_b58(sender_pk).encode(&#34;utf-8&#34;)
            enc_sender = nacl.bindings.crypto_box_seal(sender_vk, target_pk)
            sk = nacl.bindings.crypto_sign_ed25519_sk_to_curve25519(from_secret)

            nonce = nacl.utils.random(nacl.bindings.crypto_box_NONCEBYTES)
            enc_cek = nacl.bindings.crypto_box(cek, nonce, target_pk, sk)
            wrapper.add_recipient(
                JweRecipient(
                    encrypted_key=enc_cek,
                    header=OrderedDict(
                        [
                            (&#34;kid&#34;, bytes_to_b58(target_vk)),
                            (&#34;sender&#34;, b64url(enc_sender)),
                            (&#34;iv&#34;, b64url(nonce)),
                        ]
                    ),
                )
            )
        else:
            enc_sender = None
            nonce = None
            enc_cek = nacl.bindings.crypto_box_seal(cek, target_pk)
            wrapper.add_recipient(
                JweRecipient(
                    encrypted_key=enc_cek, header={&#34;kid&#34;: bytes_to_b58(target_vk)}
                )
            )</code></pre>
</details>
</dd>
<dt id="mydata_did.v1_0.utils.wallet.crypto.create_ed25519_keypair"><code class="name flex">
<span>def <span class="ident">create_ed25519_keypair</span></span>(<span>seed: bytes = None) ‑> Tuple[bytes, bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Create a public and private ed25519 keypair from a seed value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>seed</code></strong></dt>
<dd>Seed for keypair</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A tuple of (public key, secret key)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_ed25519_keypair(seed: bytes = None) -&gt; Tuple[bytes, bytes]:
    &#34;&#34;&#34;
    Create a public and private ed25519 keypair from a seed value.

    Args:
        seed: Seed for keypair

    Returns:
        A tuple of (public key, secret key)

    &#34;&#34;&#34;
    if not seed:
        seed = random_seed()
    pk, sk = nacl.bindings.crypto_sign_seed_keypair(seed)
    return pk, sk</code></pre>
</details>
</dd>
<dt id="mydata_did.v1_0.utils.wallet.crypto.create_keypair"><code class="name flex">
<span>def <span class="ident">create_keypair</span></span>(<span>key_type: <a title="mydata_did.v1_0.utils.wallet.key_type.KeyType" href="key_type.html#mydata_did.v1_0.utils.wallet.key_type.KeyType">KeyType</a>, seed: bytes = None) ‑> Tuple[bytes, bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Create a public and private keypair from a seed value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>key_type</code></strong></dt>
<dd>The type of key to generate</dd>
<dt><strong><code>seed</code></strong></dt>
<dd>Seed for keypair</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>WalletError</code></dt>
<dd>If the key type is not supported</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A tuple of (public key, secret key)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_keypair(key_type: KeyType, seed: bytes = None) -&gt; Tuple[bytes, bytes]:
    &#34;&#34;&#34;
    Create a public and private keypair from a seed value.

    Args:
        key_type: The type of key to generate
        seed: Seed for keypair

    Raises:
        WalletError: If the key type is not supported

    Returns:
        A tuple of (public key, secret key)

    &#34;&#34;&#34;
    if key_type == KeyType.ED25519:
        return create_ed25519_keypair(seed)
    else:
        raise WalletError(f&#34;Unsupported key type: {key_type.key_type}&#34;)</code></pre>
</details>
</dd>
<dt id="mydata_did.v1_0.utils.wallet.crypto.decode_pack_message"><code class="name flex">
<span>def <span class="ident">decode_pack_message</span></span>(<span>enc_message: bytes, find_key: Callable) ‑> Tuple[str, Optional[str], str]</span>
</code></dt>
<dd>
<div class="desc"><p>Decode a packed message.</p>
<p>Disassemble and unencrypt a packed message, returning the message content,
verification key of the sender (if available), and verification key of the
recipient.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>enc_message</code></strong></dt>
<dd>The encrypted message</dd>
<dt><strong><code>find_key</code></strong></dt>
<dd>Function to retrieve private key</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A tuple of (message, sender_vk, recip_vk)</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the packed message is invalid</dd>
<dt><code>ValueError</code></dt>
<dd>If the packed message reipients are invalid</dd>
<dt><code>ValueError</code></dt>
<dd>If the pack algorithm is unsupported</dd>
<dt><code>ValueError</code></dt>
<dd>If the sender's public key was not provided</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode_pack_message(
    enc_message: bytes, find_key: Callable
) -&gt; Tuple[str, Optional[str], str]:
    &#34;&#34;&#34;
    Decode a packed message.

    Disassemble and unencrypt a packed message, returning the message content,
    verification key of the sender (if available), and verification key of the
    recipient.

    Args:
        enc_message: The encrypted message
        find_key: Function to retrieve private key

    Returns:
        A tuple of (message, sender_vk, recip_vk)

    Raises:
        ValueError: If the packed message is invalid
        ValueError: If the packed message reipients are invalid
        ValueError: If the pack algorithm is unsupported
        ValueError: If the sender&#39;s public key was not provided

    &#34;&#34;&#34;
    wrapper, recips, is_authcrypt = decode_pack_message_outer(enc_message)
    payload_key, sender_vk = None, None
    for recip_vk in recips:
        recip_secret = find_key(recip_vk)
        if recip_secret:
            payload_key, sender_vk = extract_payload_key(recips[recip_vk], recip_secret)
            break

    if not payload_key:
        raise ValueError(
            &#34;No corresponding recipient key found in {}&#34;.format(tuple(recips))
        )
    if not sender_vk and is_authcrypt:
        raise ValueError(&#34;Sender public key not provided for Authcrypt message&#34;)

    message = decode_pack_message_payload(wrapper, payload_key)
    return message, sender_vk, recip_vk</code></pre>
</details>
</dd>
<dt id="mydata_did.v1_0.utils.wallet.crypto.decode_pack_message_outer"><code class="name flex">
<span>def <span class="ident">decode_pack_message_outer</span></span>(<span>enc_message: bytes) ‑> Tuple[dict, dict, bool]</span>
</code></dt>
<dd>
<div class="desc"><p>Decode the outer wrapper of a packed message and extract the recipients.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>enc_message</code></strong></dt>
<dd>The encrypted message</dd>
</dl>
<p>Returns: a tuple of the decoded wrapper, recipients, and authcrypt flag</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode_pack_message_outer(enc_message: bytes) -&gt; Tuple[dict, dict, bool]:
    &#34;&#34;&#34;
    Decode the outer wrapper of a packed message and extract the recipients.

    Args:
        enc_message: The encrypted message

    Returns: a tuple of the decoded wrapper, recipients, and authcrypt flag

    &#34;&#34;&#34;
    try:
        wrapper = JweEnvelope.from_json(enc_message)
    except ValidationError:
        raise ValueError(&#34;Invalid packed message&#34;)

    alg = wrapper.protected.get(&#34;alg&#34;)
    is_authcrypt = alg == &#34;Authcrypt&#34;
    if not is_authcrypt and alg != &#34;Anoncrypt&#34;:
        raise ValueError(&#34;Unsupported pack algorithm: {}&#34;.format(alg))

    recips = extract_pack_recipients(wrapper.recipients())
    return wrapper, recips, is_authcrypt</code></pre>
</details>
</dd>
<dt id="mydata_did.v1_0.utils.wallet.crypto.decode_pack_message_payload"><code class="name flex">
<span>def <span class="ident">decode_pack_message_payload</span></span>(<span>wrapper: <a title="mydata_did.v1_0.utils.jwe.JweEnvelope" href="../jwe.html#mydata_did.v1_0.utils.jwe.JweEnvelope">JweEnvelope</a>, payload_key: bytes) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Decode the payload of a packed message once the CEK is known.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>wrapper</code></strong></dt>
<dd>The decoded message wrapper</dd>
<dt><strong><code>payload_key</code></strong></dt>
<dd>The decrypted payload key</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode_pack_message_payload(wrapper: JweEnvelope, payload_key: bytes) -&gt; str:
    &#34;&#34;&#34;
    Decode the payload of a packed message once the CEK is known.

    Args:
        wrapper: The decoded message wrapper
        payload_key: The decrypted payload key

    &#34;&#34;&#34;
    payload_bin = wrapper.ciphertext + wrapper.tag
    message = decrypt_plaintext(
        payload_bin, wrapper.protected_bytes, wrapper.iv, payload_key
    )
    return message</code></pre>
</details>
</dd>
<dt id="mydata_did.v1_0.utils.wallet.crypto.decrypt_plaintext"><code class="name flex">
<span>def <span class="ident">decrypt_plaintext</span></span>(<span>ciphertext: bytes, recips_bin: bytes, nonce: bytes, key: bytes) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Decrypt the payload of a packed message.</p>
<h2 id="args">Args</h2>
<p>ciphertext:
recips_bin:
nonce:
key:</p>
<h2 id="returns">Returns</h2>
<p>The decrypted string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decrypt_plaintext(
    ciphertext: bytes, recips_bin: bytes, nonce: bytes, key: bytes
) -&gt; str:
    &#34;&#34;&#34;
    Decrypt the payload of a packed message.

    Args:
        ciphertext:
        recips_bin:
        nonce:
        key:

    Returns:
        The decrypted string

    &#34;&#34;&#34;
    output = nacl.bindings.crypto_aead_chacha20poly1305_ietf_decrypt(
        ciphertext, recips_bin, nonce, key
    )
    return output.decode(&#34;utf-8&#34;)</code></pre>
</details>
</dd>
<dt id="mydata_did.v1_0.utils.wallet.crypto.ed25519_pk_to_curve25519"><code class="name flex">
<span>def <span class="ident">ed25519_pk_to_curve25519</span></span>(<span>public_key: bytes) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Covert a public Ed25519 key to a public Curve25519 key as bytes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ed25519_pk_to_curve25519(public_key: bytes) -&gt; bytes:
    &#34;&#34;&#34;Covert a public Ed25519 key to a public Curve25519 key as bytes.&#34;&#34;&#34;
    return nacl.bindings.crypto_sign_ed25519_pk_to_curve25519(public_key)</code></pre>
</details>
</dd>
<dt id="mydata_did.v1_0.utils.wallet.crypto.encode_pack_message"><code class="name flex">
<span>def <span class="ident">encode_pack_message</span></span>(<span>message: str, to_verkeys: Sequence[bytes], from_secret: bytes = None) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Assemble a packed message for a set of recipients, optionally including the sender.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong></dt>
<dd>The message to pack</dd>
<dt><strong><code>to_verkeys</code></strong></dt>
<dd>The verkeys to pack the message for</dd>
<dt><strong><code>from_secret</code></strong></dt>
<dd>The sender secret</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The encoded message</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode_pack_message(
    message: str, to_verkeys: Sequence[bytes], from_secret: bytes = None
) -&gt; bytes:
    &#34;&#34;&#34;
    Assemble a packed message for a set of recipients, optionally including the sender.

    Args:
        message: The message to pack
        to_verkeys: The verkeys to pack the message for
        from_secret: The sender secret

    Returns:
        The encoded message

    &#34;&#34;&#34;
    wrapper = JweEnvelope()
    cek = nacl.bindings.crypto_secretstream_xchacha20poly1305_keygen()
    add_pack_recipients(wrapper, cek, to_verkeys, from_secret)
    wrapper.set_protected(
        OrderedDict(
            [
                (&#34;enc&#34;, &#34;xchacha20poly1305_ietf&#34;),
                (&#34;typ&#34;, &#34;JWM/1.0&#34;),
                (&#34;alg&#34;, &#34;Authcrypt&#34; if from_secret else &#34;Anoncrypt&#34;),
            ]
        ),
        auto_flatten=False,
    )
    ciphertext, nonce, tag = encrypt_plaintext(message, wrapper.protected_bytes, cek)
    wrapper.set_payload(ciphertext, nonce, tag)
    return wrapper.to_json().encode(&#34;utf-8&#34;)</code></pre>
</details>
</dd>
<dt id="mydata_did.v1_0.utils.wallet.crypto.encrypt_plaintext"><code class="name flex">
<span>def <span class="ident">encrypt_plaintext</span></span>(<span>message: str, add_data: bytes, key: bytes) ‑> Tuple[bytes, bytes, bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Encrypt the payload of a packed message.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong></dt>
<dd>Message to encrypt</dd>
<dt>add_data:</dt>
<dt><strong><code>key</code></strong></dt>
<dd>Key used for encryption</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A tuple of (ciphertext, nonce, tag)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encrypt_plaintext(
    message: str, add_data: bytes, key: bytes
) -&gt; Tuple[bytes, bytes, bytes]:
    &#34;&#34;&#34;
    Encrypt the payload of a packed message.

    Args:
        message: Message to encrypt
        add_data:
        key: Key used for encryption

    Returns:
        A tuple of (ciphertext, nonce, tag)

    &#34;&#34;&#34;
    nonce = nacl.utils.random(nacl.bindings.crypto_aead_chacha20poly1305_ietf_NPUBBYTES)
    message_bin = message.encode(&#34;utf-8&#34;)
    output = nacl.bindings.crypto_aead_chacha20poly1305_ietf_encrypt(
        message_bin, add_data, nonce, key
    )
    mlen = len(message)
    ciphertext = output[:mlen]
    tag = output[mlen:]
    return ciphertext, nonce, tag</code></pre>
</details>
</dd>
<dt id="mydata_did.v1_0.utils.wallet.crypto.extract_pack_recipients"><code class="name flex">
<span>def <span class="ident">extract_pack_recipients</span></span>(<span>recipients: Sequence[<a title="mydata_did.v1_0.utils.jwe.JweRecipient" href="../jwe.html#mydata_did.v1_0.utils.jwe.JweRecipient">JweRecipient</a>]) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Extract the pack message recipients into a dict indexed by verkey.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>recipients</code></strong></dt>
<dd>Recipients to locate</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the recipients block is mal-formatted</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_pack_recipients(recipients: Sequence[JweRecipient]) -&gt; dict:
    &#34;&#34;&#34;
    Extract the pack message recipients into a dict indexed by verkey.

    Args:
        recipients: Recipients to locate

    Raises:
        ValueError: If the recipients block is mal-formatted

    &#34;&#34;&#34;
    result = {}
    for recip in recipients:
        recip_vk_b58 = recip.header.get(&#34;kid&#34;)
        if not recip_vk_b58:
            raise ValueError(&#34;Blank recipient key&#34;)
        if recip_vk_b58 in result:
            raise ValueError(&#34;Duplicate recipient key&#34;)

        sender_b64 = recip.header.get(&#34;sender&#34;)
        enc_sender = from_b64url(sender_b64) if sender_b64 else None

        nonce_b64 = recip.header.get(&#34;iv&#34;)
        if sender_b64 and not nonce_b64:
            raise ValueError(&#34;Missing iv&#34;)
        elif not sender_b64 and nonce_b64:
            raise ValueError(&#34;Unexpected iv&#34;)
        nonce = from_b64url(nonce_b64) if nonce_b64 else None

        result[recip_vk_b58] = {
            &#34;sender&#34;: enc_sender,
            &#34;nonce&#34;: nonce,
            &#34;key&#34;: recip.encrypted_key,
        }
    return result</code></pre>
</details>
</dd>
<dt id="mydata_did.v1_0.utils.wallet.crypto.extract_payload_key"><code class="name flex">
<span>def <span class="ident">extract_payload_key</span></span>(<span>sender_cek: dict, recip_secret: bytes) ‑> Tuple[bytes, str]</span>
</code></dt>
<dd>
<div class="desc"><p>Extract the payload key from pack recipient details.</p>
<p>Returns: A tuple of the CEK and sender verkey</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_payload_key(sender_cek: dict, recip_secret: bytes) -&gt; Tuple[bytes, str]:
    &#34;&#34;&#34;
    Extract the payload key from pack recipient details.

    Returns: A tuple of the CEK and sender verkey
    &#34;&#34;&#34;
    recip_vk = sign_pk_from_sk(recip_secret)
    recip_pk = nacl.bindings.crypto_sign_ed25519_pk_to_curve25519(recip_vk)
    recip_sk = nacl.bindings.crypto_sign_ed25519_sk_to_curve25519(recip_secret)

    if sender_cek[&#34;nonce&#34;] and sender_cek[&#34;sender&#34;]:
        sender_vk_bin = nacl.bindings.crypto_box_seal_open(
            sender_cek[&#34;sender&#34;], recip_pk, recip_sk
        )
        sender_vk = sender_vk_bin.decode(&#34;utf-8&#34;)
        sender_pk = nacl.bindings.crypto_sign_ed25519_pk_to_curve25519(
            b58_to_bytes(sender_vk_bin)
        )
        cek = nacl.bindings.crypto_box_open(
            sender_cek[&#34;key&#34;], sender_cek[&#34;nonce&#34;], sender_pk, recip_sk
        )
    else:
        sender_vk = None
        cek = nacl.bindings.crypto_box_seal_open(sender_cek[&#34;key&#34;], recip_pk, recip_sk)
    return cek, sender_vk</code></pre>
</details>
</dd>
<dt id="mydata_did.v1_0.utils.wallet.crypto.seed_to_did"><code class="name flex">
<span>def <span class="ident">seed_to_did</span></span>(<span>seed: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Derive a DID from a seed value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>seed</code></strong></dt>
<dd>The seed to derive</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The DID derived from the seed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def seed_to_did(seed: str) -&gt; str:
    &#34;&#34;&#34;
    Derive a DID from a seed value.

    Args:
        seed: The seed to derive

    Returns:
        The DID derived from the seed

    &#34;&#34;&#34;
    seed = validate_seed(seed)
    verkey, _ = create_ed25519_keypair(seed)
    did = bytes_to_b58(verkey[:16])
    return did</code></pre>
</details>
</dd>
<dt id="mydata_did.v1_0.utils.wallet.crypto.sign_message"><code class="name flex">
<span>def <span class="ident">sign_message</span></span>(<span>message: Union[List[bytes], bytes], secret: bytes, key_type: <a title="mydata_did.v1_0.utils.wallet.key_type.KeyType" href="key_type.html#mydata_did.v1_0.utils.wallet.key_type.KeyType">KeyType</a>) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Sign message(s) using a private signing key.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong></dt>
<dd>The message(s) to sign</dd>
<dt><strong><code>secret</code></strong></dt>
<dd>The private signing key</dd>
<dt><strong><code>key_type</code></strong></dt>
<dd>The key type to derive the signature algorithm from</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytes</code></dt>
<dd>The signature</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sign_message(
    message: Union[List[bytes], bytes], secret: bytes, key_type: KeyType
) -&gt; bytes:
    &#34;&#34;&#34;
    Sign message(s) using a private signing key.

    Args:
        message: The message(s) to sign
        secret: The private signing key
        key_type: The key type to derive the signature algorithm from

    Returns:
        bytes: The signature

    &#34;&#34;&#34;
    # Make messages list if not already for easier checking going forward
    messages = message if isinstance(message, list) else [message]

    if key_type == KeyType.ED25519:
        if len(messages) &gt; 1:
            raise WalletError(&#34;ed25519 can only sign a single message&#34;)

        return sign_message_ed25519(
            message=messages[0],
            secret=secret,
        )
    else:
        raise WalletError(f&#34;Unsupported key type: {key_type.key_type}&#34;)</code></pre>
</details>
</dd>
<dt id="mydata_did.v1_0.utils.wallet.crypto.sign_message_ed25519"><code class="name flex">
<span>def <span class="ident">sign_message_ed25519</span></span>(<span>message: bytes, secret: bytes) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Sign message using a ed25519 private signing key.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>messages</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The message to sign</dd>
<dt><strong><code>secret</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The private signing key</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytes</code></dt>
<dd>The signature</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sign_message_ed25519(message: bytes, secret: bytes) -&gt; bytes:
    &#34;&#34;&#34;Sign message using a ed25519 private signing key.

    Args:
        messages (bytes): The message to sign
        secret (bytes): The private signing key

    Returns:
        bytes: The signature

    &#34;&#34;&#34;
    result = nacl.bindings.crypto_sign(message, secret)
    sig = result[: nacl.bindings.crypto_sign_BYTES]
    return sig</code></pre>
</details>
</dd>
<dt id="mydata_did.v1_0.utils.wallet.crypto.sign_pk_from_sk"><code class="name flex">
<span>def <span class="ident">sign_pk_from_sk</span></span>(<span>secret: bytes) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Extract the verkey from a secret signing key.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sign_pk_from_sk(secret: bytes) -&gt; bytes:
    &#34;&#34;&#34;Extract the verkey from a secret signing key.&#34;&#34;&#34;
    seed_len = nacl.bindings.crypto_sign_SEEDBYTES
    return secret[seed_len:]</code></pre>
</details>
</dd>
<dt id="mydata_did.v1_0.utils.wallet.crypto.validate_seed"><code class="name flex">
<span>def <span class="ident">validate_seed</span></span>(<span>seed: Union[bytes, str]) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a seed parameter to standard format and check length.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>seed</code></strong></dt>
<dd>The seed to validate</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The validated and encoded seed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_seed(seed: Union[str, bytes]) -&gt; bytes:
    &#34;&#34;&#34;
    Convert a seed parameter to standard format and check length.

    Args:
        seed: The seed to validate

    Returns:
        The validated and encoded seed

    &#34;&#34;&#34;
    if not seed:
        return None
    if isinstance(seed, str):
        if &#34;=&#34; in seed:
            seed = b64_to_bytes(seed)
        else:
            seed = seed.encode(&#34;ascii&#34;)
    if not isinstance(seed, bytes):
        raise WalletError(&#34;Seed value is not a string or bytes&#34;)
    if len(seed) != 32:
        raise WalletError(&#34;Seed value must be 32 bytes in length&#34;)
    return seed</code></pre>
</details>
</dd>
<dt id="mydata_did.v1_0.utils.wallet.crypto.verify_signed_message"><code class="name flex">
<span>def <span class="ident">verify_signed_message</span></span>(<span>message: Union[List[bytes], bytes], signature: bytes, verkey: bytes, key_type: <a title="mydata_did.v1_0.utils.wallet.key_type.KeyType" href="key_type.html#mydata_did.v1_0.utils.wallet.key_type.KeyType">KeyType</a>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Verify a signed message according to a public verification key.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong></dt>
<dd>The message(s) to verify</dd>
<dt><strong><code>signature</code></strong></dt>
<dd>The signature to verify</dd>
<dt><strong><code>verkey</code></strong></dt>
<dd>The verkey to use in verification</dd>
<dt><strong><code>key_type</code></strong></dt>
<dd>The key type to derive the signature verification algorithm from</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if verified, else False</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def verify_signed_message(
    message: Union[List[bytes], bytes],
    signature: bytes,
    verkey: bytes,
    key_type: KeyType,
) -&gt; bool:
    &#34;&#34;&#34;
    Verify a signed message according to a public verification key.

    Args:
        message: The message(s) to verify
        signature: The signature to verify
        verkey: The verkey to use in verification
        key_type: The key type to derive the signature verification algorithm from

    Returns:
        True if verified, else False

    &#34;&#34;&#34;
    # Make messages list if not already for easier checking going forward
    messages = message if isinstance(message, list) else [message]

    if key_type == KeyType.ED25519:
        if len(messages) &gt; 1:
            raise WalletError(&#34;ed25519 can only verify a single message&#34;)

        return verify_signed_message_ed25519(
            message=messages[0], signature=signature, verkey=verkey
        )
    else:
        raise WalletError(f&#34;Unsupported key type: {key_type.key_type}&#34;)</code></pre>
</details>
</dd>
<dt id="mydata_did.v1_0.utils.wallet.crypto.verify_signed_message_ed25519"><code class="name flex">
<span>def <span class="ident">verify_signed_message_ed25519</span></span>(<span>message: bytes, signature: bytes, verkey: bytes) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Verify an ed25519 signed message according to a public verification key.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong></dt>
<dd>The message to verify</dd>
<dt><strong><code>signature</code></strong></dt>
<dd>The signature to verify</dd>
<dt><strong><code>verkey</code></strong></dt>
<dd>The verkey to use in verification</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if verified, else False</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def verify_signed_message_ed25519(
    message: bytes, signature: bytes, verkey: bytes
) -&gt; bool:
    &#34;&#34;&#34;
    Verify an ed25519 signed message according to a public verification key.

    Args:
        message: The message to verify
        signature: The signature to verify
        verkey: The verkey to use in verification

    Returns:
        True if verified, else False

    &#34;&#34;&#34;
    try:
        nacl.bindings.crypto_sign_open(signature + message, verkey)
    except nacl.exceptions.BadSignatureError:
        return False
    return True</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="mydata_did.v1_0.utils.wallet" href="index.html">mydata_did.v1_0.utils.wallet</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="mydata_did.v1_0.utils.wallet.crypto.add_pack_recipients" href="#mydata_did.v1_0.utils.wallet.crypto.add_pack_recipients">add_pack_recipients</a></code></li>
<li><code><a title="mydata_did.v1_0.utils.wallet.crypto.create_ed25519_keypair" href="#mydata_did.v1_0.utils.wallet.crypto.create_ed25519_keypair">create_ed25519_keypair</a></code></li>
<li><code><a title="mydata_did.v1_0.utils.wallet.crypto.create_keypair" href="#mydata_did.v1_0.utils.wallet.crypto.create_keypair">create_keypair</a></code></li>
<li><code><a title="mydata_did.v1_0.utils.wallet.crypto.decode_pack_message" href="#mydata_did.v1_0.utils.wallet.crypto.decode_pack_message">decode_pack_message</a></code></li>
<li><code><a title="mydata_did.v1_0.utils.wallet.crypto.decode_pack_message_outer" href="#mydata_did.v1_0.utils.wallet.crypto.decode_pack_message_outer">decode_pack_message_outer</a></code></li>
<li><code><a title="mydata_did.v1_0.utils.wallet.crypto.decode_pack_message_payload" href="#mydata_did.v1_0.utils.wallet.crypto.decode_pack_message_payload">decode_pack_message_payload</a></code></li>
<li><code><a title="mydata_did.v1_0.utils.wallet.crypto.decrypt_plaintext" href="#mydata_did.v1_0.utils.wallet.crypto.decrypt_plaintext">decrypt_plaintext</a></code></li>
<li><code><a title="mydata_did.v1_0.utils.wallet.crypto.ed25519_pk_to_curve25519" href="#mydata_did.v1_0.utils.wallet.crypto.ed25519_pk_to_curve25519">ed25519_pk_to_curve25519</a></code></li>
<li><code><a title="mydata_did.v1_0.utils.wallet.crypto.encode_pack_message" href="#mydata_did.v1_0.utils.wallet.crypto.encode_pack_message">encode_pack_message</a></code></li>
<li><code><a title="mydata_did.v1_0.utils.wallet.crypto.encrypt_plaintext" href="#mydata_did.v1_0.utils.wallet.crypto.encrypt_plaintext">encrypt_plaintext</a></code></li>
<li><code><a title="mydata_did.v1_0.utils.wallet.crypto.extract_pack_recipients" href="#mydata_did.v1_0.utils.wallet.crypto.extract_pack_recipients">extract_pack_recipients</a></code></li>
<li><code><a title="mydata_did.v1_0.utils.wallet.crypto.extract_payload_key" href="#mydata_did.v1_0.utils.wallet.crypto.extract_payload_key">extract_payload_key</a></code></li>
<li><code><a title="mydata_did.v1_0.utils.wallet.crypto.seed_to_did" href="#mydata_did.v1_0.utils.wallet.crypto.seed_to_did">seed_to_did</a></code></li>
<li><code><a title="mydata_did.v1_0.utils.wallet.crypto.sign_message" href="#mydata_did.v1_0.utils.wallet.crypto.sign_message">sign_message</a></code></li>
<li><code><a title="mydata_did.v1_0.utils.wallet.crypto.sign_message_ed25519" href="#mydata_did.v1_0.utils.wallet.crypto.sign_message_ed25519">sign_message_ed25519</a></code></li>
<li><code><a title="mydata_did.v1_0.utils.wallet.crypto.sign_pk_from_sk" href="#mydata_did.v1_0.utils.wallet.crypto.sign_pk_from_sk">sign_pk_from_sk</a></code></li>
<li><code><a title="mydata_did.v1_0.utils.wallet.crypto.validate_seed" href="#mydata_did.v1_0.utils.wallet.crypto.validate_seed">validate_seed</a></code></li>
<li><code><a title="mydata_did.v1_0.utils.wallet.crypto.verify_signed_message" href="#mydata_did.v1_0.utils.wallet.crypto.verify_signed_message">verify_signed_message</a></code></li>
<li><code><a title="mydata_did.v1_0.utils.wallet.crypto.verify_signed_message_ed25519" href="#mydata_did.v1_0.utils.wallet.crypto.verify_signed_message_ed25519">verify_signed_message_ed25519</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>